\JWlone{Methods}
\label{sec:methods}

\JWltwo{Checked Bi--Randomized Variables}
\label{sec:cbrv}

The RV technique (see section \ref{sec:rv}) prevents the
second party from directly gaining intermediate information. But, for a
corrupted second party, there is still the possibility of gaining supplemental
information: The second party could forge an RV value before applying it to one
of the following AREs. This will not directly reveal additional information
because the second party does not know the encryption keys used for the RV. So,
the second party is unaware of the decoded value of the RV. But except for a
negligible probability $\left(\frac{1}{Char(K)}\right)$, the decoded value is
non--zero.  The knowledge of a random but non--zero value can then be used to
test a secret input of the first party against zero. \JWtodo{Beispiel hierf√ºr,
siehe z.B. Google Doc.}

To address this issue, a similar but secure technique is proposed in here: The
\emph{Checked Bi--Randomized Variables} (CBRVs). Every input made to an OAFE by
the second party is encoded as a CBRV. The CBRVs $\hat{v}$ corresponding to a
value $v$ are: ($\alpha_l, \alpha_r \in K \setminus \{0\}; \beta, \beta' \in K$)

\begin{align*}
  \widetilde{v} = (\widetilde{v_1}, \widetilde{v_2}) =
  (\alpha_l \cdot v + \beta, \alpha_r \cdot v + \beta')
\end{align*}

\noindent{} $\alpha_l$ and $\alpha_r$ are the \emph{static keys}, $\beta$ and
$\beta'$ the \emph{dynamic keys} of the CBRV. The static keys are (non--zero)
numbers uniformly at random but constant for the entire procedure. $\beta$ and
$\beta'$ are fresh, independent and uniformly distributed random numbers for
every CBRV component generated while processing a circuit. Only the first party
knows these secret keys. The initial CBRVs used to feed the second party's
regular inputs party are generated using an OAFE that evaluates for every input
$x$:

\begin{align*}
  \widetilde{x} = (\alpha_l \cdot x + \beta_1, \alpha_r \cdot x + \beta_2)
\end{align*}

The first party is---because it generates and knows all the keys---in possession
of the encoding and decoding functions

\begin{align*}
  E(x) &= \left(\alpha_l \cdot x + \beta_1, \alpha_r \cdot x + \beta_2\right) \\
  D(\widetilde{x}) &= \left(\frac{\widetilde{x_1} - \beta_1}{\alpha_l},
                       \frac{\widetilde{x_2} - \beta_2}{\alpha_r}\right)
\end{align*}

A CBRF $\widetilde{x}$ is well--formed iff the tuple $D(\widetilde{x})$ consists
of two equal values.


\JWltwo{Checked Bi-Randomized Affine Encodings}
\label{sec:cbrae}

\emph{Checked Bi-Randomized Affine Encodings} (CBRAEs) are very similar to AREs
(section \ref{sec:are}) but use CBRVs (section \ref{sec:cbrv}) instead of plain
values and RVs (section \ref{sec:rv}).

\begin{align}
  \mathcal{V} = & \{ x \mid x~\text{a variable over}~K \} \\
%
  \mathcal{F}_{AR} = & \{ s \cdot x + i \mid s, i \in K, x \in \mathcal{V} \}
  \cup \{ v \mid v \in K \} \\
%
  \mathcal{B}_{AR} = & \{ (\alpha_l \cdot f + \beta, \alpha_r \cdot f + \beta' )
  \mid \alpha_l, \alpha_r \in K \setminus \{0\}; \beta, \beta' \in K; f \in
  \mathcal{F}_{AR} \} \\
%
  \label{rel:cbrae}
  \mathcal{E}_{AR} = & \{ (M, A) \mid
    M \subseteq \mathcal{B}_{AR} \times \mathcal{B}_{AR},
    A \subseteq, \mathcal{B}_{AR};
    A, M~\text{finite multi--sets} \}
%
\end{align}

\noindent Intuitively, $\mathcal{V}$ are ordinary inputs and CBRVs,
$\mathcal{F}_{AR}$ represent linear, encrypted particles that encode parts of
the final function. To prevent illegal information gaining by a corrupted second
party, $\mathcal{B}_{AR}$ represents checked and encoded intermediate values
(see section \ref{sec:cbrv}) that can safely be passed to untrusted parties.
$\mathcal{E}_{AR}$ is the final encoding, powerful enough to encode arbitrary
arithmetic functions. $\mathcal{E}_{AR}$s are full--blown CBRAEs as presented in
this thesis. The decoding part remains as in section
\ref{sec:affinization_decoding}. The result will be a tuple that can then be
decoded in one last step as in section \ref{sec:eval-final-value}.


\JWlthree{Encoding Arithmetic Operations as CBRAEs}
\label{sec:encode-cbrae}

As in section \ref{sec:cbrv} we assume the universal decoding function
$D(\widetilde{x})$. With CBRVs, the arithmetic operations are mapped as follows:


\JWlfour{Addition}

Two CBRVs $\widetilde{x}$ and $\widetilde{y}$ can be added componentwise to
$\widetilde{z} = \left(\widetilde{x_1} + \widetilde{y_1}, \widetilde{x_2} +
\widetilde{y_2}\right)$. Since the first party is in
possession of the encryption keys ($\widetilde{x} = \left(\alpha_l \cdot x +
\beta_1, \alpha_r \cdot x + \beta_2\right)$, $\widetilde{y} = \left(\alpha_l
\cdot x + \beta_3, \alpha_r \cdot x + \beta_4\right)$) it's obvious that:
$\widetilde{z} = \left(\alpha_l \cdot (x+y) + (\beta_1 + \beta_3), \alpha_r
\cdot (x+y) + (\beta_2 + \beta_4)\right)$ and $\widetilde{z}$ is well--formed.

Having two CBRAEs, they can be added by simply concatenating the multiplicative
($M$ in relation \ref{rel:cbrae}) and additive ($A$) parts.


\JWlfour{Addition -- Alternative Form}

The alternative addition form is
$\widetilde{z} =
\left( E\left(D(\widetilde{x_1}) + D(\widetilde{y_1})\right),
       E\left(D(\widetilde{x_2}) + D(\widetilde{y_2})\right)
\right)$.
Since $E(x)$ and $D(x)$ are both linear functions,
$E\left(D(\ldots) +D(\ldots)\right)$
are linear expressions, too that can be evaluated using two OAFE calls.


\JWlfour{Multiplication}

As for ordinary AREs, the multiplication is not as powerful as the addition,
direct multiplication of two CBRAEs is not possible. CBRAE multiplication is
done using CBRVs sent to the second party. Then, these CBRVs get multiplied as
described here:

\begin{align*}
  e & \in \mathcal{E}_{AR}; \widetilde{x}, \widetilde{y} \in \mathcal{B}_{RV};
  r_1, r_2, r_3, r_4, r_5, r_6, r_7, r_8 \in K;
  \alpha_l, \alpha_r \in K \setminus \{0\} \\
  %
  e & = \widetilde{x} \otimes \widetilde{y} \\
  %
  e & = \Bigg(\Big\{\big( \alpha_l \cdot D(\widetilde{x_1}) - r_1,
                          \alpha_r \cdot D(\widetilde{x_2}) -r_5 \big) \\
    &\qquad ,     \big(   1        \cdot D(\widetilde{y_1}) - r_2,
                          1        \cdot D(\widetilde{y_2}) - r_6 \big) \Big\}\\
    &\qquad   \Big\{\big( \alpha_lr_2 \cdot D(\widetilde{x_2}) + r_3,
                          \alpha_rr_2 \cdot D(\widetilde{x_1}) + r_7 \big) \\
    &\qquad ,       \big ( r_1        \cdot D(\widetilde{y_2}) + r_4,
                           r_5        \cdot D(\widetilde{y_1}) + r_8 \big)
              \Big\}\Bigg) \\
\end{align*}

The decryption keys of $e$ are $\alpha_l$, $\alpha_r$ (static keys) and
$\beta = r_1r_2 + r_3 + r_4$, $\beta' = r_5r_6 + r_7 + r_8$ (dynamic keys).


\JWlthree{Evaluating the Final Value}
\label{sec:eval-final-value}

In contrast to the RV technique (section \ref{sec:rv}), the
CBRV technique encodes all values. So even the final value, the result of the
entire calculation, is encrypted. The encryption works as follows: After
evaluation the last CBRAE, the second party is in possession of an CBRV tuple
$\widetilde{r} = (\widetilde{r_1}, \widetilde{r_2})$. The second party then
calculates $\widehat{r} = \widetilde{r_1} + \widetilde{r_2}$ and decodes it to
$r$ using a specific final OAFE. This OAFE was set up by the first party at the
beginning as follows: Assuming $\widetilde{r_1}$ was encrypted using $(\alpha_l,
\beta_{r_1})$ and $\widetilde{r_2}$ was encrypted using $(\alpha_r,
\beta_{r_2})$ the first party knows $\widehat{r}$ has to be encrypted using
$(\alpha_l + \alpha_r, \beta_{r_1} + \beta_{r_2})$. Given this knowledge the
final OAFE setup is $\frac{1}{\alpha_l + \alpha_r} \cdot \widehat{r} -
\frac{\beta_{r_1} + \beta_{r_2}}{\alpha_l + \alpha_r}$.

The gain of this technique is that the second party is getting caught if it
cheated. If it cheated somewhere in the process and forged one of its CBRV
tuples $\widetilde{x} = (\widetilde{x_1}, \widetilde{x_2})$ to $\widetilde{x'} =
(\widetilde{x_1} + \Delta_1, \widetilde{x_2} + \Delta_2)$, the CBRV
$\widetilde{x'}$ becomes---except for a negligible probability---non--wellformed
(see section \ref{sec:cbrv}). The result is that the final
result will become uniform randomness (assuming $\widetilde{x}$ is forged to
$\widetilde{x'_1} = \widetilde{x_1} + \Delta_1$ and $\widetilde{x'_2} =
\widetilde{x_2} + \Delta_2$):

\begin{align*}
  \widehat{x'} = & \widetilde{x'_1} + \widetilde{x'_2} = \widetilde{x_1} +
  \Delta_1 + \widetilde{x_2} + \Delta_2 \\
  %
  \Rightarrow x' = & \frac{1}{\alpha_l + \alpha_r} \cdot \widehat{x'} -
  \frac{\beta_{x_1} +
  \beta_{x_2}}{\alpha_l + \alpha_r} \\
  %
  \Leftrightarrow x' = & \frac{\widetilde{x_1} + \Delta_1 +
  \widetilde{x_2} + \Delta_2}{\alpha_l + \alpha_r} -
  \frac{\beta_{x_1} +\beta_{x_2}}{\alpha_l + \alpha_r}\\
  %
  \Leftrightarrow x' = & \frac{(\alpha_l x + \beta_{x_1}) + \Delta_1 +
  (\alpha_r x + \beta_{x_2}) + \Delta_2}{\alpha_r + \alpha_l} -
  \frac{\beta_{x_1} +\beta_{x_2}}{\alpha_l + \alpha_r} \\
  %
  \Leftrightarrow x' = & \frac{(\alpha_l+\alpha_r)x + (\beta_{x_1}+\beta_{x_2} +
  \Delta_1+\Delta_2)}{\alpha_l+\alpha_r} -
  \frac{\beta_{x_1} +\beta_{x_2}}{\alpha_l + \alpha_r} \\
  %
  \Leftrightarrow x' = & x + \frac{\beta_{x_1}+\beta_{x_2}}{\alpha_l+\alpha_r}
  + \frac{\Delta_1 + \Delta_2}{\alpha_l + \alpha_r} -
  \frac{\beta_{x_1}+\beta_{x_2}}{\alpha_l + \alpha_r} \\
  %
  \Leftrightarrow x' = & x + \frac{\Delta_1 + \Delta_2}{\alpha_l + \alpha_r}
\end{align*}


%
% PREPARING CBRAE EVALUATION USING OAFEs
%
\JWltwo{Preparing CBRAE Evaluation Using OAFEs}
\label{sec:prep-eval}

After transforming an arithmetic expressing to CBRAEs (section \ref{sec:cbrae})
assigned to CBRVs (section \ref{sec:cbrv}) the OAFEs (\cite{davidgoliath}) need
to be set up. First of all, two separate OAFEs have to be set up for each CBRV
that can be evaluated later on as soon the value is known. The OAFEs are
configured with the linear expressions inside the CBRAEs. Each CBRAE is then
transformed to two \emph{Encoding Descriptors} (EDs) that have the same
structure as the CBRAEs but contain OAFE references instead of linear
expressions. Therefore, each CBRAE assigned to a CBRV gets transformed to two
EDs, because of the tuple form of the CBRVs and CBRAEs.


%
% OBLIVIOUS POLYNOMIAL EVALUATION
%
\JWltwo{Oblivious Polynomial Evaluation}
\label{sec:ope}

This section describes the whole process of obliviously evaluating a univariate
polynomial $f(x) = \sum_{i=1}^k a_ix^i$. The first party (\JWpOne{}) fixes the
polynomial and configures the OAFEs, the second party (\JWpTwo{}) chooses input
$x$. Eventually, \JWpTwo{} will learn $f(x)$ but not the polynomial's
coefficients $a_i$. \JWpOne{} will not learn anything at all.

The first step is to transform $f$ to OAFEs and EDs (section
\ref{sec:prep-eval}). The OAFEs are then sent to the second party (\JWpTwo{})
using the David \& Goliath protocol \cite{davidgoliath}, the EDs are sent to the
second party using an encrypted channel aswell.

After having received the OAFEs and EDs, the first party (\JWpOne{}) is not
needed anymore and the second party (\JWpTwo{}) can evaluate the polynomial by
itself. To run the evaluation, the second party just evaluated the EDs one by
one. After each evaluation, it queries the respective OAFE (should be the next)
with the value if did just calculate. After having calculated the last to ED
values, it queries a special OAFE (see section \ref{sec:eval-final-value}) using
the addition of the values of the last two EDs. The evaluation of the special
OAFE is the result of the whole computation.
