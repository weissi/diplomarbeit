\JWlone{Correctness and Security of the Protocol}
\label{sec:security}

This chapter states and proofs the security of the protocol in the
\JWdef{Universal--Composability}{UC} framework by Ran Canetti \cite{canetti05}.
In the UC framework security is defined by comparing an \emph{ideal model} to a
\emph{real model}. The ideal model implements the intended functionality
\JWfuncSym{}{} safely by definition. The protocol under examination runs in the
real model. In the real model, there is an adversary $\mathcal{A}$ that controls
all corrupted parties.  In the ideal model, there is a simulator $\mathcal{S}$
that tries to mimic $\mathcal{A}$. An environment $\mathcal{Z}$ is plugged to
either the real or the ideal model and has to guess to which it's plugged to. A
protocol \JWprotoSym{}{} is an universally composable implementation of the
ideal functionality if for every adversary $\mathcal{A}$ there is a
simulator $\mathcal{S}$ such that for all environments $\mathcal{Z}$ the entire
view of $\mathcal{Z}$ in the real model (with \JWprotoSym{}{} and $\mathcal{A}$)
is statistically close to its view in the ideal model (with \JWfuncSym{}{} and
$\mathcal{S}$).

\begin{align*}
%
\forall \mathcal{A}\ \exists \mathcal{S}\ \forall \mathcal{Z} :
\text{ideal}\ \widetilde{=}\ \text{real}
%
\end{align*}

%
% SIMULATORS
%
\JWltwo{Simulators}
\label{sec:simulators}


% SIMULATOR S_DAVID(A)
\JWlthree{Simulator $\mathcal{S}_{\text{\JWpTwo{}}}(\mathcal{A})$}
\label{sec:simulator-david}

\paragraph{Setup Phase:}

\begin{itemize}

  \item Setup an emulated version of the given real model adversary
    \JWadv{} which especially impersonates the corrupted \JWpTwo{}.

  \item Setup emulated, honest \JWpOne{} labeled $\mathcal{G}$.

  \item Setup emulated, honest OAFE functionality labeled \JWfuncSymOAFE{}.

  \item Initialize $\mathcal{G}$ with a random polynomial of the parametrized
    degree $k$ and record the DRAC $C$ it generated.

  \item Wire $\mathcal{G}$, \JWfuncSymOAFE{} and \JWadv{} to each other
    and \JWadv{} to the environment as in the real model.

  \item Start the simulation by transitioning in the \emph{Processing Phase}.

\end{itemize}

\paragraph{Processing Phase:}

\begin{itemize}

  \item Intercept the adversary's (\JWadv{}) polynomial input $x$. This is
    trivial because it is the first message that \JWadv{} transmits to
    \JWfuncSymOAFE{} and was not ignored by \JWfuncSymOAFE{}. Notice, this is
    the initial DRAV encoding of the plain value $x$. Next, halt the simulation
    and evaluate the proper polynomial using the intercepted input $x$ and the
    ideal functionality \JWfuncSymOPEnp{} by sending it \JWmsgTP{Evaluate}{$x$}.

  \item Upon receiving \JWmsgTP{Evaluated}{$y$} from \JWfuncSymOPEnp{},
    calculate the value $\chi$ which an honest \JWpTwo{} would evaluate the last
    OAFE with. Because an honest \JWpTwo{} acts entirely deterministic, this
    calculates from the stored DRAC $C$, the OAFE parameters in \JWfuncSymOAFE,
    and the stored input $x$. Next, draw a random value $r$ and calculate $\psi
    = \frac{y-r}{\chi}$. Next, reconfigure the parameters of the last OAFE to
    $(\psi, r)$. The last OAFE then calculates the affine function $f(\eta) =
    \psi \cdot \eta + r$ which---when evaluated with $\chi$---calculates the
    result $y$ of the proper polynomial at the node $x$. Since any honest
    \JWpTwo{} evaluates the last OAFE with $\chi$, any honest \JWpTwo{} will
    receive the correct result $y = f(\chi) = \psi \cdot \chi + r =
    \frac{y-r}{\chi} \cdot \chi + r = y$. Any dishonest \JWpTwo{} will receive
    some random value depending on the random value $r$. Finally unhalt the
    simulation.

\end{itemize}


% SIMULATOR S_Goliath(A)
\JWlthree{Simulator $\mathcal{S}_{\text{Goliath}}(\mathcal{A})$}
\label{sec:simulator-goliath}

The setup phase is run as soon as the simulator starts.

\paragraph{Setup Phase:}

\begin{itemize}

  \item Setup emulated, honest \JWpTwo{} and OAFE functionality
    \JWfuncSymOAFE{}.

  \item Wire the given real model adversary \JWadv{} that impersonates \JWpOne{}
    with the emulated \JWpTwo{} and \JWfuncSymOAFE{}. Additionally wire \JWadv{}
    with the environment the way they would be wired in the real model.

\end{itemize}

\paragraph{Processing Phase:}

\begin{itemize}

  \item Upon the emulated OAFE functionality received the OAFE configuration and
    the emulated \JWpTwo{} received the DRAC, symbolically evaluate the
    polynomial that \JWadv{} described. During the symbolic evaluation, the OAFE
    functionality configuration could proof to be unfitting: \JWadv{} could
    have sent a configuration that allows too few OAFE evaluations or evaluates
    to vectors of wrong shape. In both cases, modify the configuration to return
    all zero vectors of the correct shape whenever the DRAC evaluation would
    fail otherwise.

  \item After having symbolically evaluated the polynomial encoded by \JWadv{},
    verify, that the polynomial has a degree that is less or equal than the
    parametrized degree $k$. If \JWadv{} submitted a polynomial of valid degree,
    store the polynomial's coefficients as $a \in \JWfieldGeneral^n$.  Next,
    upload that polynomial to the ideal functionality \JWfuncSymOPEnp{} by
    outputting \JWmsgTP{Commit}{$a$} to \JWfuncSymOPEnp{}.  If the polynomial
    was illegal, restart the simulator in the setup phase.  This restart is
    equivalent to ignoring the adversary's inputs.

\end{itemize}


%
% PROOF
%
\JWltwo{Security Proof}
\label{sec:proof}

The proof is a case distinction.


% CORRECTNESS --- BOTH PARTIES HONEST
\JWlthree{Correctness---Both Parties Honest}

\JWtodo{In richtigen Worten hinschreiben}

Easy, just works.



% BOTH PARTIES CORRUPTED
\JWlthree{Both Parties Corrupted}

\JWtodo{In richtigen Worten hinschreiben}

The case that both parties are corrupted is just an hypothetical case in the UC
model.


% CORRUPTED DAVID
\JWlthree{Corrupted \JWpTwo{}}

This chapter will proof the security of the proposed protocol \JWprotoSymOPE
in the Universal Composability (UC) framework \cite{canetti05} against both,
passive and active adversaries impersonating \JWpTwo{}. Passive adversaries are
adversaries which try to calculate additional information from intermediate
results, active adversaries additionally misuse the protocol in any way.

The protocol is trivially secure against passive adversaries impersonating
\JWpTwo{} because every value that gets transmitted to \JWpTwo{} is one--time
encrypted. The values that transmitted to \JWpTwo{} are part of a DRAEs and
DRAEs only contain references to OAFEs and DRAVs. Chapter \ref{def:DRAV} proves
(Lemma \ref{lem:DRAV-random}) that DRAV only transport uncorrelated uniform
randomness to parties not in possession of the encryption keys. The OAFE
evaluations lead further (one--time encrypted) DRAVs and radicals (see chapter
\ref{sec:sec-muls}) that are one--time encrypted as well. The simulator from
chapter \ref{sec:simulator-david} plays on this property and encodes a random
polynomial of the same degree that is used to test \JWpTwo{}'s honesty. In fact,
because every value is one--time encrypted, the protocol is perfectly secure
against any passive adversary.

For the security against a actively corrupted \JWpTwo{} a hybrid argument is
employed. The general idea is to transform a actively corrupted adversary into a
passively corrupted adversary and to show that the statistical distance in the
environment's view is negligible. For to random variables $x$ and $y$
statistical distance $D_S$ is denoted using the following standard notation.

\begin{align*}
  %
  D_S(x, y) = \frac{\sum_\alpha \left|Pr[x=\alpha] - Pr[y=\alpha]\right|}{2}
  %
\end{align*}

\noindent{}The first step is to attach a \emph{monitor module} between the
adversary \JWadv{} and the OAFE functionality \JWfuncSymOAFE{}. The monitor
module is parametrized by a transcript how an honest \JWpTwo{} would act. The
task of the module is to analyze the messages that \JWpTwo{} (impersonated by
the adversary) sends to the OAFE functionality. If it detects that \JWpTwo{}
sends a message (that would not be ignored by \JWfuncSymOAFE{}) that does not
equal the same message in the honest transcript, it changes this message to
match the honest message. Additionally it intercepts the response changed
message from \JWfuncSymOAFE{} and changes the response to some value uniformly
at random. The monitor module does this change only once, if the adversary
changes one of the following messages, the monitor module does no changes and
acts like a cable. The union of the adversary \JWadv{} and the monitor module
can be seen as a transformed adversary \JWadv{}' which is forging (at the
earliest) the message following the first message that \JWadv{} illicitly
changed. So, if \JWadv{} forges $n$ messages, \JWadv{}' forgest at most $n-1$
messages.

The interesting part is the statistical distance of the environment's between
\JWadv{} and \JWadv{}'. The message which \JWadv{} will receive from the monitor
module after having forged a message for the first time is uniform randomness.
This will render some DRAV that is computed with the message to a
non--well--formed DRAV with overwhelming probability ($1-1/|\mathbb{K}| =
1-1/2^k$) because only one element of the finite field $\mathbb{K}$ matches its
counterpart tuple component (its MAC see chapter \ref{sec:sec-muls}). Therefore,
the statistical distance of the environment's view between \JWadv{} and
\JWadv{}' is:

\begin{align*}
  %
  D_s(\text{view}_\mathcal{Z}(\mathcal{A}),
  \text{view}_\mathcal{Z}(\mathcal{A}'))
  \leq \frac{1}{|\mathbb{K}|}
  = \frac{1}{2^k}
  %
\end{align*}

\noindent{}This argument can be used inductive until the original adversary
\JWadv{} is transformed to a passive adversary $\mathcal{A}^*$. Because the
triangle inequality holds for the statistical distance and the maximal number of
OAFEs used for a polynomial of degree $n$ is in $O(n)$ the statistical distance
of any active adversary \JWadv{} and a passive adversary $\mathcal{A}^*$ is

\begin{align*}
  %
  D_s(\text{view}_\mathcal{Z}(\mathcal{A}),
  \text{view}_\mathcal{Z}(\mathcal{A}^*))
  \leq \frac{O(n)}{2^k}
  %
\end{align*}

\noindent{}And because $k$ is the security parameter, the statistical distance
in the environment's view between any active adversary and any passive adversary
is negligible. As stated above, the protocol is perfectly secure against any
passive adversary and therefore UC--secure against any active adversary. \qed



% CORRUPTED GOLIATH
\JWlthree{Corrupted \JWpOne{}}

A corrupted \JWpOne{} has the following possibilities to cheat:

\begin{enumerate}

  \item Describe a polynomial with a degree greater that the parametrized
    maximal degree.

  \item Configure the OAFE functionality in a way that the DRAC evaluation would
    fail because it assumes additional evaluation possibilities or vectors of
    other shapes.

  \item Send messages that do not describe a valid DRAC\@.

\end{enumerate}

Both, the ideal model (running the simulator from \ref{sec:simulator-goliath})
as well as in the real model (running the \JWprotoSymOPE{} and the adversary)
handle these possibilities indistinguishably for any environment:

\begin{enumerate}

  \item Both, the protocol and the simulator verify the polynomial's degree.
    Both ignore the input when the degree is greater than parametrized.

  \item If the OAFE functionality is configured in a wrong way, both handle this
    case similarly: Vectors of wrong shapes are turned to the all zero vector of
    the correct shape. Missing OAFE evaluations are assumed to return the all
    zero vector of the expected shape.

  \item Messages that do not validly describe a DRAC are ignored.

\end{enumerate}

This assures any environment will not be able to distinguish between the real
and the ideal model.

% vim: set spell spelllang=en_us fileencoding=utf8 :
