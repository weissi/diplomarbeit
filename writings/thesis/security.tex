\JWlone{Correctness and Security of the Protocol}
\label{sec:security}

This chapter states and proofs the security of the protocol in the
\JWdef{Universal--Composability}{UC} framework by Ran Canetti \cite{canetti05}.
In the UC framework security is defined by comparing an \emph{ideal model} to a
\emph{real model}. The ideal model implements the intended functionality
\JWfuncSym{}{} safely by definition. The protocol under examination runs in the
real model. In the real model, there is an attacker $\mathcal{A}$ that controls
all corrupted parties.  In the ideal model, there is a simulator $\mathcal{S}$
that tries to mimic $\mathcal{A}$. An environment $\mathcal{Z}$ is plugged to
either the real or the ideal model and has to guess to which it's plugged to. A
protocol \JWprotoSym{}{} is an universally composable implementation of the
ideal functionality if for every adversary $\mathcal{A}$ there exists a
simulator $\mathcal{S}$ such that for all environments $\mathcal{Z}$ the entire
view of $\mathcal{Z}$ in the real model (with \JWprotoSym{}{} and $\mathcal{A}$)
is statistically close to its view in the ideal model (with \JWfuncSym{}{} and
$\mathcal{S}$).

\begin{align*}
%
\forall \mathcal{A}\ \exists \mathcal{S}\ \forall \mathcal{Z} :
\text{ideal}\ \widetilde{=}\ \text{real}
%
\end{align*}

%
% SIMULATORS
%
\JWltwo{Simulators}
\label{sec:simulators}


% SIMULATOR S_DAVID(A)
\JWlthree{Simulator $\mathcal{S}_{\text{\JWpTwo{}}}(\mathcal{A})$}
\label{sec:simulator-david}

\paragraph{Setup Phase}

The setup phase is run as soon as the simulator starts.


\subparagraph{Setup Reference System:}

The reference system is used to review the honesty of the corrupted \JWpTwo{} in
the real model. The messages send from the corrupted \JWpTwo{} are compared
to the values the honest, emulated \JWpTwo{} sends in the reference system.

\begin{itemize}

  \item Setup emulated, honest \JWpOne{} labeled $\mathcal{G}^R$.

  \item Setup emulated, honest OAFE functionality \JWfuncSymOAFE{}
    labeled $\mathcal{F}^R_{OAFE}$.

  \item Setup emulated, honest \JWpTwo{} labeled $\mathcal{D}^R$.
    $\mathcal{D}^R$ should not send an initial message (its polynomial input)
    until notified by the simulator.

  \item Wire $\mathcal{G}^R$, $\mathcal{F}^R_{OAFE}$, and $\mathcal{D}^R$ as
    usual.

  \item Initialize $\mathcal{G}^R$ with a random polynomial of the parametrized
    degree.

\end{itemize}


\subparagraph{Setup Test System:}

The test system is wired to the corrupted \JWpTwo{} (labeled $\mathcal{D}^C$) in
the real model.

\begin{itemize}

  \item Setup emulated, honest \JWpOne{} labeled $\mathcal{G}^T$.

  \item Setup emulated, honest OAFE functionality \JWfuncSymOAFE{}
    labeled $\mathcal{F}^T_{OAFE}$.

  \item Wire $\mathcal{G}^T$, $\mathcal{F}^T_{OAFE}$ and $\mathcal{D}^C$ as
    usual. Every message that gets send from $\mathcal{D}^C$ should be
    intercepted and checked by the simulator.

  \item Initialize $\mathcal{G}^T$ with the same polynomial $\mathcal{G}^R$ got
    initialized.

\end{itemize}


\subparagraph{General Setup:}

\begin{itemize}

  \item Setup a variable \JWcode{cheated $\leftarrow$ $false$}.

\end{itemize}


\paragraph{Regular Processing Phase:}

The regular processing phase starts as soon as the setup phase is terminated.

\begin{itemize}

  \item Intercept \JWpTwo{}'s ($\mathcal{D}^C$) polynomial input. This is
    trivial because it is the first message that \JWpTwo{} transmits to the OAFE
    functionality \JWfuncSymOAFE{}. Now verify the input $x$ fulfills $x \in
    F_{2^k}$ and store $x$, else ignore that input.

  \item Upon an verified $x$ is stored, send \JWmsgTP{Evaluate}{$x$} to the
    reference \JWpTwo{} $\mathcal{D}^R$. This will start the evaluation process
    for $\mathcal{D}^R$.

  \item Until evaluating the last OAFE the simulation has to intercept all
    messages from the corrupted \JWpTwo{} and adapt the scheduling of the
    reference system to match the test system.

  \item As soon as a message from the corrupted \JWpTwo{} $\mathcal{D}^C$ is
    intercepted, compare it to the according message of the reference \JWpTwo{}
    ($\mathcal{D}^R$). Should the message from the corrupted \JWpTwo{} differ
    from the message from reference \JWpTwo{} or should the corrupted \JWpTwo{}
    send an additional message, \JWpTwo{} is caught while trying to cheat. If
    \JWpTwo{} was caught while trying to cheat, set \JWcode{cheated $\leftarrow$
    $true$} and continue normally.

  \item As soon as the corrupted $\mathcal{D}^C$ has sent its last message to
    the OAFE functionality check it as above and halt the test and the reference
    systems.

\end{itemize}

\paragraph{The Last Step:}

\begin{itemize}

  \item Output \JWmsgTP{Evaluate}{$x$} to \JWfuncSymOPEnp{}, this evaluates the
    polynomial using the ideal OPE functionality using \JWpTwo{}'s intercepted
    input $x$.

  \item Upon receiving \JWmsgTP{Evaluated}{$y$} from \JWfuncSymOPEnp{}, store
    the polynomial's evaluated result $y$.

  \item The final step analyzes the variable \JWcode{cheated} and modifies the
    final OAFE accordingly. If \JWcode{cheated $= true$} modify the final OAFE
    to evaluate to a value at random but unequal to the real result. (e.g. an
    affine function $0 \cdot x + y + r$ where $r \in K \setminus \{0\}$ is
    fresh, uniform randomness). If \JWcode{cheated $= false$}, the final OAFE
    gets modified such that evaluating the next step honestly evaluates to the
    evaluated polynomial's result (e.g. by an affine function $0 \cdot x + y$
    where $y$ is the evaluated polynomial's value.

  \item Unhalt the reference system to allow $\mathcal{D}^C$ to fetch the final
    result.

\end{itemize}


% SIMULATOR S_Goliath(A)
\JWlthree{Simulator $\mathcal{S}_{\text{Goliath}}(\mathcal{A})$}
\label{sec:simulator-goliath}

The setup phase is run as soon as the simulator starts.

\paragraph{Setup Phase:}

\begin{itemize}

  \item Setup emulated, honest \JWpTwo{} and OAFE functionality
    \JWfuncSymOAFE{}.

  \item Wire the possibly corrupted \JWpOne{}, the emulated \JWpTwo{} and
    \JWfuncSymOAFE{} as usual.

\end{itemize}

\paragraph{Processing Phase:}

\begin{itemize}

  \item Upon the emulated OAFE functionality received the OAFE configuration and
    the emulated \JWpTwo{} received the DRAC, symbolically evaluate the
    polynomial \JWpOne{} described. During the symbolic evaluation, the OAFE
    functionality configuration could proof to be unfitting: \JWpOne{} could
    have sent a configuration that allows too few OAFE evaluations or evaluates
    to vectors of wrong shape. In both cases, modify the configuration to return
    all zero vectors of the correct shape whenever the DRAC evaluation would
    fail otherwise.

  \item After having symbolically evaluated the polynomial encoded by \JWpOne{},
    verify, that the polynomial has a degree that is less or equal than the
    parametrized degree $k$. If \JWpOne{} submitted a polynomial of valid
    degree, store the polynomial's coefficients as $a \in \JWfieldGeneral^n$.
    Next, upload that polynomial to the ideal functionality \JWfuncSymOPEnp{} by
    outputting \JWmsgTP{Commit}{$a$} to \JWfuncSymOPEnp{}.  If the polynomial
    was illegal, restart the simulator in the setup phase.  This restart is
    equivalent to simply ignoring \JWpOne{}'s inputs.

\end{itemize}


%
% PROOF
%
\JWltwo{Security Proof}
\label{sec:proof}

The proof is a case distinction.


% CORRECTNESS --- BOTH PARTIES HONEST
\JWlthree{Correctness --- Both Parties Honest}

Easy, just works.



% BOTH PARTIES CORRUPTED
\JWlthree{Both Parties Corrupted}

The case that both parties are corrupted is just an hypothetical case in the UC
model.


% CORRUPTED DAVID
\JWlthree{Corrupted \JWpTwo{}}

Using the simulator from chapter \ref{sec:simulator-david}.

\JWtodo{Rewrite proof}


% CORRUPTED GOLIATH
\JWlthree{Corrupted \JWpOne{}}

A corrupted \JWpOne{} has the following possibilities to cheat:

\begin{enumerate}

  \item Describe a polynomial with a degree greater that the parametrized
    maximal degree.

  \item Configure the OAFE functionality in a way that the DRAC evaluation would
    fail because it assumes additional evaluation possibilities or vectors of
    other shapes.

  \item Send messages that do not describe a valid DRAC.

\end{enumerate}

Both, the ideal model (running \JWfuncSymOPEnp{} and the simulator from chapter
\ref{sec:simulator-goliath}) as well as in the real model (running
\JWprotoSymOPE{}) handle these possibilities indistinguishably for any
environment:

\begin{enumerate}

  \item Both, the protocol and the simulator verify the polynomial's degree.
    Both ignore the input when the degree is greater than parametrized.

  \item If the OAFE functionality is configured in a wrong way, both handle this
    case similarly: Vectors of wrong shapes are turned to the all zero vector of
    the correct shape. Missing OAFE evaluations are assumed to return the all
    zero vector of the expected shape.

  \item Messages that do not validly describe a DRAC are ignored.

\end{enumerate}

This assures any environment will not be able to distinguish between the real
and the ideal model.

% vim: set spell spelllang=en_us fileencoding=utf8 :
