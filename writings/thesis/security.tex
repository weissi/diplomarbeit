\JWlone{Correctness and Security of the Protocol}
\label{sec:security}

This chapter states and proofs the security of the protocol in the
\JWdef{Universal--Composability}{UC} framework by Ran Canetti \cite{canetti05}.
In the UC framework security is defined by comparing an \emph{ideal model} to a
\emph{real model}. The ideal model implements the intended functionality
\JWfuncSym{}{} safely by design.  The protocol under examination runs in the
real model. In the real model, there is an attacker $\mathcal{A}$ that controls
all corrupted parties.  In the ideal model, there is a simulator $\mathcal{S}$
that tries to mimic $\mathcal{A}$. An environment $\mathcal{Z}$ is plugged to
either the real or the ideal model and has to guess to which it's plugged to. A
protocol \JWprotoSym{}{} is an universally composable implementation of the
ideal functionality if for every adversary $\mathcal{A}$ there exists a
simulator $\mathcal{S}$ such that for all environments $\mathcal{Z}$ the entire
view of $\mathcal{Z}$ in the real model (with \JWprotoSym{}{} and $\mathcal{A}$)
is statistically close to its view in the ideal model (with \JWfuncSym{}{} and
$\mathcal{S}$).

\begin{align*}
%
\forall \mathcal{A}\ \exists \mathcal{S}\ \forall \mathcal{Z} :
\text{ideal}\ \widetilde{=}\ \text{real}
%
\end{align*}

%
% SIMULATORS
%
\JWltwo{Simulators}
\label{sec:simulators}


% SIMULATOR S_DAVID(A)
\JWlthree{Simulator $\mathcal{S}_{\text{\JWpTwo{}}}(\mathcal{A})$}
\label{sec:simulator-david}

\paragraph{Setup Phase}

The setup phase is run as soon as the simulator starts.


\subparagraph{Setup Reference System:}

The reference system is used to review the honesty of the corrupted \JWpTwo{} in
the real model. The messages send from the corrupted \JWpTwo{} are compared
to the values the honest, emulated \JWpTwo{} sends in the reference system.

\begin{itemize}

  \item Setup emulated, honest \JWpOne{} labeled $\mathcal{G}^R$.

  \item Setup emulated, honest OAFE functionality \JWfuncSym{seq-ot}{OAFE}
    labeled $\mathcal{F}^R_{OAFE}$.

  \item Setup emulated, honest \JWpTwo{} labeled $\mathcal{D}^R$.
    $\mathcal{D}^R$ should not send an initial message (its polynomial input)
    until notified by the simulator.

  \item Wire $\mathcal{G}^R$, $\mathcal{F}^R_{OAFE}$, and $\mathcal{D}^R$ as
    usual.

  \item Initialize $\mathcal{G}^R$ with a random polynomial of the parametrized
    degree.

\end{itemize}


\subparagraph{Setup Test System:}

The test system is wired to the corrupted \JWpTwo{} (labeled $\mathcal{D}^C$) in
the real model.

\begin{itemize}

  \item Setup emulated, honest \JWpOne{} labeled $\mathcal{G}^T$.

  \item Setup emulated, honest OAFE functionality \JWfuncSym{seq-ot}{OAFE}
    labeled $\mathcal{F}^T_{OAFE}$.

  \item Wire $\mathcal{G}^T$, $\mathcal{F}^T_{OAFE}$ and $\mathcal{D}^C$ as
    usual. Every message that gets send from $\mathcal{D}^C$ should be
    intercepted and checked by the simulator.

  \item Initialize $\mathcal{G}^T$ with the same polynomial $\mathcal{G}^R$ got
    initialized.

\end{itemize}


\subparagraph{General Setup:}

\begin{itemize}

  \item Setup a variable \JWcode{cheated $\leftarrow$ $false$}.

\end{itemize}


\paragraph{Regular Processing Phase:}

The regular processing phase starts as soon as the setup phase is terminated.

\begin{itemize}

  \item Intercept \JWpTwo{}'s ($\mathcal{D}^C$) polynomial input. This is
    trivial: It's the first message that \JWpTwo{} transmits to the OAFE
    functionality

  \item Ask the reference \JWpTwo{} $\mathcal{D}^R$ to send the same output to
    OAFE functionality wired to it.

  \item Until evaluating the last OAFE the simulation has just to adapt the
    scheduling of the reference system to match the test system.

  \item As soon as a message from the corrupted \JWpTwo{} $\mathcal{D}^C$ is
    received, compare it to the according message of the reference \JWpTwo{}
    ($\mathcal{D}^R$). Should the message from the corrupted \JWpTwo{} differ
    from the message from reference \JWpTwo{} or should the corrupted \JWpTwo{}
    send an additional message, \JWpTwo{} is caught while trying to cheat. If
    \JWpTwo{} was caught while trying to cheat, set \JWcode{cheated $\leftarrow$
    $true$} and continue normally.

  \item As soon as the corrupted $\mathcal{D}^C$ has sent its last message to
    the OAFE functionality check it as above and halt the test and the reference
    system.

\end{itemize}

\paragraph{The Last Step:}

\begin{itemize}

  \item The final step analyzes the variable \JWcode{cheated} and modifies the
    final OAFE accordingly. If \JWcode{cheated $=$ $true$} modify the final OAFE
    to evaluate to uniform randomness (e.g. an affine function $0 \cdot x + r$
    where $r$ is fresh, uniform randomness).  If \JWcode{cheated $=$ $false$},
    the ideal functionality is used to evaluate the polynomial using \JWpTwo{}'s
    intercepted input. Afterwards, the final OAFE gets modifies such
    that evaluating the next step honestly evaluates to the evaluated
    polynomial's result (e.g. by an affine function $0 \cdot x + y$ where $y$ is
    the evaluated polynomial's value.

  \item Unhalt the reference system to allow $\mathcal{D}^C$ to fetch the final
    result.

\end{itemize}


% SIMULATOR S_Goliath(A)
\JWlthree{Simulator $\mathcal{S}_{\text{Goliath}}(\mathcal{A})$}
\label{sec:simulator-goliath}

\begin{itemize}

  \item Setup an emulated, honest \JWpOne{}

  \item Feed the emulated \JWpOne{} with the same inputs the corrupted \JWpOne{}
    receives

  \item

\end{itemize}


%
% PROOF
%
\JWltwo{Security Proof}
\label{sec:proof}

The proof is a case distinction.


% CORRECTNESS --- BOTH PARTIES HONEST
\JWlthree{Correctness --- Both Parties Honest}

Easy, just works.



% BOTH PARTIES CORRUPTED
\JWlthree{Both Parties Corrupted}

The case that both parties are corrupted is just an hypothetical case in the UC
model.


% CORRUPTED DAVID
\JWlthree{Corrupted \JWpTwo{}}

Use the simulator from chapter \ref{sec:simulator-david}. Since everything
except the last value that gets transmitted to \JWpTwo{} is a DRAV, it's
uniformly at random because of the ever--changing dynamic keys $(\beta, \beta')$
(see Lemma \ref{lem:DRAV-random}). The last value is---depending on the
honestness---either uniform random, too or the final value.


% CORRUPTED GOLIATH
\JWlthree{Corrupted \JWpOne{}}

Use the simulator from chapter \ref{sec:simulator-goliath}. Perfectly secure.

% vim: set spell spelllang=en_us fileencoding=utf8 :
