\JWlone{Correctness and Security of the Protocol}
\label{sec:security}

This chapter states and proofs the security of the protocol in the
\JWdef{Universal--Composability}{UC} framework by Ran Canetti \cite{canetti05}.
In the UC framework security is defined by comparing an \emph{ideal model} to a
\emph{real model}. The ideal model implements the intended functionality
\JWfuncSym{}{} safely by definition. The protocol under examination runs in the
real model. In the real model, there is an attacker $\mathcal{A}$ that controls
all corrupted parties.  In the ideal model, there is a simulator $\mathcal{S}$
that tries to mimic $\mathcal{A}$. An environment $\mathcal{Z}$ is plugged to
either the real or the ideal model and has to guess to which it's plugged to. A
protocol \JWprotoSym{}{} is an universally composable implementation of the
ideal functionality if for every adversary $\mathcal{A}$ there exists a
simulator $\mathcal{S}$ such that for all environments $\mathcal{Z}$ the entire
view of $\mathcal{Z}$ in the real model (with \JWprotoSym{}{} and $\mathcal{A}$)
is statistically close to its view in the ideal model (with \JWfuncSym{}{} and
$\mathcal{S}$).

\begin{align*}
%
\forall \mathcal{A}\ \exists \mathcal{S}\ \forall \mathcal{Z} :
\text{ideal}\ \widetilde{=}\ \text{real}
%
\end{align*}

%
% SIMULATORS
%
\JWltwo{Simulators}
\label{sec:simulators}


% SIMULATOR S_DAVID(A)
\JWlthree{Simulator $\mathcal{S}_{\text{\JWpTwo{}}}(\mathcal{A})$}
\label{sec:simulator-david}

\paragraph{Setup Phase}

The setup phase is run as soon as the simulator starts.


\subparagraph{Setup Reference System:}

The reference system is used to review the honesty of the corrupted \JWpTwo{} in
the real model. The messages send from the corrupted \JWpTwo{} are compared
to the values the honest, emulated \JWpTwo{} sends in the reference system.

\begin{itemize}

  \item Setup emulated, honest \JWpOne{} labeled $\mathcal{G}^R$.

  \item Setup emulated, honest OAFE functionality \JWfuncSym{seq-ot}{OAFE}
    labeled $\mathcal{F}^R_{OAFE}$.

  \item Setup emulated, honest \JWpTwo{} labeled $\mathcal{D}^R$.
    $\mathcal{D}^R$ should not send an initial message (its polynomial input)
    until notified by the simulator.

  \item Wire $\mathcal{G}^R$, $\mathcal{F}^R_{OAFE}$, and $\mathcal{D}^R$ as
    usual.

  \item Initialize $\mathcal{G}^R$ with a random polynomial of the parametrized
    degree.

\end{itemize}


\subparagraph{Setup Test System:}

The test system is wired to the corrupted \JWpTwo{} (labeled $\mathcal{D}^C$) in
the real model.

\begin{itemize}

  \item Setup emulated, honest \JWpOne{} labeled $\mathcal{G}^T$.

  \item Setup emulated, honest OAFE functionality \JWfuncSym{seq-ot}{OAFE}
    labeled $\mathcal{F}^T_{OAFE}$.

  \item Wire $\mathcal{G}^T$, $\mathcal{F}^T_{OAFE}$ and $\mathcal{D}^C$ as
    usual. Every message that gets send from $\mathcal{D}^C$ should be
    intercepted and checked by the simulator.

  \item Initialize $\mathcal{G}^T$ with the same polynomial $\mathcal{G}^R$ got
    initialized.

\end{itemize}


\subparagraph{General Setup:}

\begin{itemize}

  \item Setup a variable \JWcode{cheated $\leftarrow$ $false$}.

\end{itemize}


\paragraph{Regular Processing Phase:}

The regular processing phase starts as soon as the setup phase is terminated.

\begin{itemize}

  \item Intercept \JWpTwo{}'s ($\mathcal{D}^C$) polynomial input. This is
    trivial: It's the first message that \JWpTwo{} transmits to the OAFE
    functionality

  \item Ask the reference \JWpTwo{} $\mathcal{D}^R$ to send the same output to
    OAFE functionality wired to it.

  \item Until evaluating the last OAFE the simulation has just to adapt the
    scheduling of the reference system to match the test system.

  \item As soon as a message from the corrupted \JWpTwo{} $\mathcal{D}^C$ is
    received, compare it to the according message of the reference \JWpTwo{}
    ($\mathcal{D}^R$). Should the message from the corrupted \JWpTwo{} differ
    from the message from reference \JWpTwo{} or should the corrupted \JWpTwo{}
    send an additional message, \JWpTwo{} is caught while trying to cheat. If
    \JWpTwo{} was caught while trying to cheat, set \JWcode{cheated $\leftarrow$
    $true$} and continue normally.

  \item As soon as the corrupted $\mathcal{D}^C$ has sent its last message to
    the OAFE functionality check it as above and halt the test and the reference
    system.

\end{itemize}

\paragraph{The Last Step:}

\begin{itemize}

  \item The ideal functionality is used to evaluate the polynomial using
    \JWpTwo{}'s intercepted input. The evaluated result is named $y$ in the
    following steps.

  \item The final step analyzes the variable \JWcode{cheated} and modifies the
    final OAFE accordingly. If \JWcode{cheated $=$ $true$} modify the final OAFE
    to evaluate to a value at random but unequal to the real result. (e.g. an
    affine function $0 \cdot x + y + r$ where $r \in K \setminus \{0\}$ is
    fresh, uniform randomness). If \JWcode{cheated $=$ $false$}, the final OAFE
    gets modified such that evaluating the next step honestly evaluates to the
    evaluated polynomial's result (e.g. by an affine function $0 \cdot x + y$
    where $y$ is the evaluated polynomial's value.

  \item Unhalt the reference system to allow $\mathcal{D}^C$ to fetch the final
    result.

\end{itemize}


% SIMULATOR S_Goliath(A)
\JWlthree{Simulator $\mathcal{S}_{\text{Goliath}}(\mathcal{A})$}
\label{sec:simulator-goliath}

The setup phase is run as soon as the simulator starts.

\paragraph{Setup Phase:}

\begin{itemize}

  \item Setup emulated, honest \JWpTwo{} and OAFE functionality.

  \item Wire the possibly corrupted \JWpOne{}, the emulated \JWpTwo{} and the
    emulated OAFE functionality as usual.

\end{itemize}

\paragraph{Processing Phase:}

\begin{itemize}

  \item Upon the emulated OAFE functionality received the OAFE configuration and
    the emulated \JWpTwo{} received the DRAC, symbolically evaluate the
    polynomial \JWpOne{} described. During the symbolic evaluation, the OAFE
    functionality configuration could proof as unfitting: \JWpOne{} could have
    sent a configuration that allows too few OAFE evaluations or the returned
    vectors could be of the wrong shape. In both cases, modify the configuration
    to return all zero vectors of the correct shape whenever the DRAC evaluation
    would fail otherwise.
  \item After having symbolically evaluated the polynomial encoded by \JWpOne{},
    verify, that the polynomial has a degree that is less or equal than the
    parametrized degree $k$. If \JWpOne{} submitted a polynomial of valid
    degree, upload that polynomial to the ideal functionality \JWfuncSymOPE{}.
    If the polynomial was illegal, restart the simulator in the setup phase.
    This restart is equivalent to simply ignoring \JWpOne{}'s inputs.

\end{itemize}


%
% PROOF
%
\JWltwo{Security Proof}
\label{sec:proof}

The proof is a case distinction.


% CORRECTNESS --- BOTH PARTIES HONEST
\JWlthree{Correctness --- Both Parties Honest}

Easy, just works.



% BOTH PARTIES CORRUPTED
\JWlthree{Both Parties Corrupted}

The case that both parties are corrupted is just an hypothetical case in the UC
model.


% CORRUPTED DAVID
\JWlthree{Corrupted \JWpTwo{}}

Using the simulator from chapter \ref{sec:simulator-david}, \JWpTwo{} will only
ever see uniform randomness except for the result of the final OAFE which is the
result of the overall evaluation. The final OAFE will either
return the correctly calculated output or uniform randomness.

In the real model this is not different because a DRAV only consists of uniform
randomness that is uncorrelated to any other DRAV (Lemma \ref{lem:DRAV-random}).
Additionally a well--formed DRAV is indistinguishable from any non--well--formed
DRAV (Lemma \ref{lem:DRAV-indistinguishable}). This proofs that the proposed
protocol is perfectly secure against every passively corrupted \JWpTwo{}.

An actively corrupted \JWpTwo{} has only the following five additional attack
possibilities:

\begin{enumerate}

\item \label{av-ad:input} Forge the input value.

\item \label{av-ad:DRAV} Forge one or more DRAVs.

\item \label{av-ad:other-ops} Perform additional additions.

\item \label{av-ad:less-ops} Perform less arithmetic operations
  (additions/multiplications).

\item \label{av-ad:last-OAFE} Forge the input to the last OAFE.

\end{enumerate}


The proposed protocol is secure against point \ref{av-ad:input} because this is
the same as simply changing the input value. That is by definition not an attack
but a free choice every \JWpTwo{} can take.

The protocol is secure against point \ref{av-ad:DRAV} because an polynomial is a
circuit with exactly one root, the output value. The value of every node take
part in the calculation of the final result. Since DRAV forging is equivalent to
calculation involving a wrong DRAV (Lemma \ref{lem:well-formed-fun-of-dec-fun})
we only consider DRAV forging (non--well--formed DRAVs). The propagation of
every non--well--formed DRAV to the final result is guaranteed because only two
operations are defined: Multiplications and additions and both propagate
non--well--formed operands: If one non--well--formed DRAV is an operand of a
multiplication, the multiplication result is again a non--well--formed DRAV (see
chapter \ref{sec:DRAE-multiplication}). The same argument holds for additions,
additionally performed additions and additions not performed as requested
(Lemmas \ref{lem:DRAV-add}, \ref{lem:DRAV-add-bad} and \ref{lem:wrong-add}).
Therefore an attack attempt on a DRAV is equivalent to replacing the output
value of the DRAE that has the DRAV as one of its inputs by uniform randomness.
Since this has to propagate until the root of the tree (the result!), any
attempt to forge a DRAV will result in uniform randomness.

Since additionally performed additions are equivalent to additions involving
unintended operands, every attempt to do so (point \ref{av-ad:other-ops}) is
caught (see Lemma \ref{lem:wrong-add}).

Since DRAV well--formedness is a function of the decryption function
(\ref{lem:well-formed-fun-of-dec-fun}) performing less operations is not
feasible without knowing the encryption keys. Since \JWpTwo{} is not in
possession of the keys, point \ref{av-ad:less-ops} does not break the protocol.

Finally, the protocol is perfectly secure against point \ref{av-ad:last-OAFE}
because an attempt to cheat results in uniform randomness. In the case of
the final OAFE it results in uniform randomness unequal the real result (see
chapter \ref{sec:drav-final-decoding}).


% CORRUPTED GOLIATH
\JWlthree{Corrupted \JWpOne{}}

A corrupted \JWpOne{} has the following possibilities to cheat:

\begin{enumerate}

  \item Describe a polynomial with a degree greater that the parametrized
    maximal degree.

  \item Configure the OAFE functionality in a way that the DRAC evaluation would
    fail because it assumes additional evaluation possibilities or vectors of
    other shapes.

  \item Send messages that do not describe a valid DRAC.

\end{enumerate}

Both, the ideal model (running \JWfuncSymOPE{} and the simulator from chapter
\ref{sec:simulator-goliath}) as well as in the real model (running
\JWprotoSymOPE{}) handle these possibilities indistinguishably for any
environment:

\begin{enumerate}

  \item Both, the protocol and the simulator verify the polynomial's degree.
    Both ignore the input when the degree is greater than parametrized.

  \item If the OAFE functionality is configured in a wrong way, both handle this
    case similarly: Vectors of wrong shapes are turned to the all zero vector of
    the correct shape. Missing OAFE evaluations are assumed to return the all
    zero vector of the expected shape.

  \item Messages that do not validly describe a DRAC are ignored.

\end{enumerate}

This assures any environment will not be able to distinguish between the real
and the ideal model.

% vim: set spell spelllang=en_us fileencoding=utf8 :
