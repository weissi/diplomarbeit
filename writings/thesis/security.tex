\JWlone{Correctness and Security of the Protocol}
\label{sec:security}

This chapter states and proofs the security of the protocol in the
\JWdef{Universal--Composability}{UC} framework by Ran Canetti \cite{canetti05}.
In the UC framework security is defined by comparing an \emph{ideal model} to a
\emph{real model}. The ideal model implements the intended functionality
\JWfuncSym{}{} safely by design.  The protocol under examination runs in the
real model. In the real model, there is an attacker $\mathcal{A}$ that controls
all corrupted parties.  In the ideal model, there is a simulator $\mathcal{S}$
that tries to mimic $\mathcal{A}$. An environment $\mathcal{Z}$ is plugged to
either the real or the ideal model and has to guess to which it's plugged to. A
protocol \JWprotoSym{}{} is an universally composable implementation of the
ideal functionality if for every adversary $\mathcal{A}$ there exists a
simulator $\mathcal{S}$ such that for all environments $\mathcal{Z}$ the entire
view of $\mathcal{Z}$ in the real model (with \JWprotoSym{}{} and $\mathcal{A}$)
is statistically close to its view in the ideal model (with \JWfuncSym{}{} and
$\mathcal{S}$).

\begin{align*}
%
\forall \mathcal{A}\ \exists \mathcal{S}\ \forall \mathcal{Z} :
\text{ideal}\ \widetilde{=}\ \text{real}
%
\end{align*}

%
% SIMULATORS
%
\JWltwo{Simulators}
\label{sec:simulators}


% SIMULATOR S_DAVID(A)
\JWlthree{Simulator $\mathcal{S}_{\text{\JWpTwo{}}}(\mathcal{A})$}
\label{sec:simulator-david}

\begin{itemize}

  \item Setup emulated honest \JWpOne{}, OAFE functionality and \JWpTwo{}, wired
    as usual.

  \item Choose a random polynomial of the correct degree as the input for the
    emulated \JWpOne{}

  \item At the start, as soon as the corrupted \JWpTwo{} transmits its first
    output to the OAFE functionality (sets its variable), let the emulated
    \JWpTwo{} make the same input.

  \item From now on, compare all data from the corrupted \JWpTwo{} to the
    outputs of the emulated \JWpTwo{}.

  \item Should the corrupted \JWpTwo{} behave different than the emulated
    \JWpTwo{}, return uniform randomness as the final output

  \item Should the corrupted \JWpTwo{} behave honestly, pass it's input to the
    ideal functionality and output the return value to the environment

\end{itemize}


% SIMULATOR S_Goliath(A)
\JWlthree{Simulator $\mathcal{S}_{\text{Goliath}}(\mathcal{A})$}
\label{sec:simulator-goliath}

\begin{itemize}

  \item Setup an emulated, honest \JWpOne{}

  \item Feed the emulated \JWpOne{} with the same inputs the corrupted \JWpOne{}
    receives

  \item

\end{itemize}


%
% PROOF
%
\JWltwo{Security Proof}
\label{sec:proof}

The proof is a case distinction.


% CORRECTNESS --- BOTH PARTIES HONEST
\JWlthree{Correctness --- Both Parties Honest}

Easy, just works.



% BOTH PARTIES CORRUPTED
\JWlthree{Both Parties Corrupted}

The case that both parties are corrupted is just an hypothetical case in the UC
model.


% CORRUPTED DAVID
\JWlthree{Corrupted \JWpTwo{}}

Use the simulator from chapter \ref{sec:simulator-david}. Since everything
except the last value that gets transmitted to \JWpTwo{} is a DRAV, it's
uniformly at random because of the ever--changing dynamic keys $(\beta,
\beta')$. The last value is---depending on the honestness---either uniform
random, too or the final value.


% CORRUPTED GOLIATH
\JWlthree{Corrupted \JWpOne{}}

Use the simulator from chapter \ref{sec:simulator-goliath}. Perfectly secure.

% vim: set spell spelllang=en_us fileencoding=utf8 :
