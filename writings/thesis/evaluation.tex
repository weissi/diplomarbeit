\JWlone{Evaluation}
\label{sec:evaluation}

%
% TEST SETUP
%
\JWltwo{Test Setup}
\label{sec:test-setup}

\JWlthree{Test Maschines}
\label{sec:test-machines}

Both test machines are regular home computer systems thus the benchmarks were
not run under laboratory conditions. Though, most background services and other
programs that could interfere with the benchmarks have been stopped. The
implementation has been compiled using full optimizations turned on
(\JWcmd{cabal configure --ghc-options=-O3}).


\JWlfour*{Test Maschine 1}

\emph{Dell Latitude D620} running \emph{Debian GNU/Linux} on kernel version
\emph{3.1.7, 32--bit}. The machine is powered by a \emph{Intel\TReg{} Core Duo
T2400} dual core processor at \emph{1.83 GHz}. It has \emph{2 GB} system memory.


\JWlfour*{Test Maschine 2}

\emph{Apple Mac mini} (\texttt{Macmini 3,1}) running \emph{MacOS X 10.7.5
(Lion), 64--bit}. The machine is powered by a \emph{Intel\TReg{} Core 2 Duo}
dual core processor at \emph{2.26 GHz}. It has \emph{8 GB} system memory.

\JWlthree{Benchmarking Process}

Both machines run the three programs (\JWBpOne{}, \JWBpTwo{}, \JWBtoken{})
simultaneously, the programs are compiled single--threaded. The programs
communicate to each other using local TCP/IP networking. Chapter
\ref{sec:communication-channels} has an in depth description about the
communication that takes part in the implementation that comes with this thesis.
The running time includes the DRAC building and transmitting, the OAFE
configuration and the successful evaluation of a random polynomial. The
polynomial is evaluated using \emph{Horner's rule}\cite{cormen01}. The data
points in all figures and tables were obtained by taking the median of
running the same benchmark five times in a row (preceded by a non--accounted
warm--up run).


%
% COMPUTATIONAL COMPLEXITY
%
\JWltwo{Computational Complexity}
\label{sec:comp-complexity}

Ordinary evaluation of a polynomial of degree $n$ using \emph{Horner's rule} is
in $\Theta(n)$ \cite{cormen01}. Despite the complex technique presented in this
thesis the overall evaluation time is still in $\Theta(n)$. This is true for
both, the theoretical examination and the implementation. Figure
\ref{fig:poly-deg-t} and table \ref{tab:poly-deg-t} show this for the finite
field $\mathbb{F}_{97}$ (implementation from the \JWTLhaskellForMaths{}
package). The implementation for the field $\mathbb{F}_{2^{256}}$ does not seem
have linear time complexity, the cause is the unoptimal implementation and the
Haskell binding of the library used for the calculations in
$\mathbb{F}_{2^{256}}$. The problem is that the library includes a rather
complex routine for object destruction that takes most of the evaluation time.
The root of the problem is that functional languages prefer immutable
(unchangeable) objects with very fast construction/destruction and the C++
library that was interfaced is optimized for as few constructions/destructions
as possible and the use of mutable objects. The phenomenon that is observable
when using this library is that the garbage collector is taking up most of the
running time (up to $85\%$) waiting for the library destruction routine. For
high performance (such as the pure Haskell implementation for $\mathbb{F}_{97}$)
another library should be interfaced or developed entirely in Haskell, but this
is not the main concern of this thesis. For futher details see chapter
\ref{sec:finite-field-calcs}. For smaller degrees the current implementation for
$\mathbb{F}_{2^{256}}$ has linear time complexity. Figure
\ref{fig:poly-deg-t-small} and table \ref{tab:poly-deg-t-small} show
this. It is also noteworthy that the first test machine (see chapter
\ref{sec:test-machines}) outperforms the second test machine despite the
inferior hardware. The cause has not been investigated, a possible cause could
be that the 64--bit \JWTghc{} runtime seems to be slower (at least on Apple
Macs)\cite{lentczner11}.


% F97 vs. F2Pow256 and Linux vs. Mac
\begin{figure}[ht]
  \centering
  \input{images/poly-deg-t}
  \caption{Evaluation Time of Polynomial by Degree}
  \label{fig:poly-deg-t}
\end{figure}

\begin{table}[ht]
  \centering
  \begin{tabular}{|c|c|c|}
    Polynomial Degree & Running Time $\mathbb{F}_{97}$ [s] & Running Time
    $\mathbb{F}_{2^{256}}$ [s]\\
    %
      500 &  1.754 &   2.389 \\
     1000 &  3.673 &   6.032 \\
     1500 &  5.587 &  10.159 \\
     2000 &  7.400 &  15.179 \\
     2500 &  9.104 &  20.702 \\
     3000 & 10.905 &  25.560 \\
     3500 & 12.800 &  31.978 \\
     4000 & 14.549 &  39.926 \\
     4500 & 16.422 &  47.248 \\
     5000 & 18.288 &  55.450 \\
     5500 & 20.142 &  63.496 \\
     6000 & 22.000 &  72.293 \\
     6500 & 23.901 &  85.184 \\
     7000 & 25.654 &  93.694 \\
     7500 & 27.670 & 104.231 \\
     8000 & 29.510 & 117.480 \\
     8500 & 31.518 & 127.848 \\
     9000 & 33.417 & 143.123 \\
     9500 & 35.525 & 156.820 \\
    10000 & 37.395 & 172.216 \\

  \end{tabular}
  \caption{Evaluation Time of Polynomials by Degree on Test Machine 1}
  \label{tab:poly-deg-t}
\end{table}

\begin{figure}[ht]
  \centering
  \input{images/poly-deg-t-small}
  \caption{\JWtodo{NEU mit Radical Encryption}Evaluation Time of Polynomial
  (Smaller Degrees) on Test Machine 1}
  \label{fig:poly-deg-t-small}
\end{figure}

\begin{table}[ht]
  \centering
  \begin{tabular}{|c|c|}
    \JWtodo{Neumachen mit Radical encryption} \\
    Polynomial Degree & Average Running Time [ms] \\
    0  & 68.4 \\
    10 &  80.2 \\
    20 & 101.2 \\
    30 & 121.6 \\
    40 & 142.6 \\
    50 & 160.8 \\
    60 & 183.0 \\
    70 & 208.0 \\
    80 & 232.2 \\
    90 & 258.4 \\
    100 & 280.4 \\
    110 & 307.2 \\
    120 & 321.2 \\
    130 & 347.2 \\
    140 & 372.8 \\
    150 & 402.6 \\
    160 & 429.4 \\
    170 & 470.8 \\
    180 & 484.4 \\
    190 & 508.0 \\
    200 & 527.8 \\
    210 & 563.8 \\
    220 & 601.6 \\
    230 & 606.8 \\
    240 & 640.0 \\
  \end{tabular}
  \caption{Evaluation Time of Polynomial (Smaller Degrees) on Test Machine 1}
  \label{tab:poly-deg-t-small}
\end{table}


%
% MEMORY COMPLEXITY
%
\JWltwo{Memory Complexity}
\label{sec:mem-complexity}

The memory complexity of the current implementation is in $O(n)$, $n$ being the
polynomial's degree, too. The reason is that the implementation has to store all
DRAEs to be able to generate the OAFE configuration and to write the OAFE
references in the DRAEs.


%
% CONTRIBUTION
%
\JWltwo{Contribution}
\label{sec:contribution}

The main contribution of this thesis is UC--secure (against actively corrupted
parties) \emph{Oblivious Polynomial Evaluation} (see chapter \ref{def:OPE}) in
linear time. For restricted security requirements (secure against actively
corrupted function evaluating party but only secure against passively corrupted
function definition party) arbitrary arithmetic circuits (include Square \&
Multiply) are possible using the techniques presented in chapter
\ref{sec:methods}.

For the main case---Oblivious Polynomial Evaluation---this thesis also
contributes a working implementation.


%
% OPEN QUESTIONS AND OUTLOOK
%
\JWltwo{Open Questions and Outlook}
\label{sec:outlook}

The most important open question is to find an improvement for the current
technique to support arbitrary arithmetic circuits by maintaining the computing
time complexity and the UC--security against all actively corrupted parties.

The implementation would benefit by a better implementation of a library for
calculations in large finite fields such as $\mathbb{F}_{2^{k}}$ for $k > 128$.
Additionally, the David \& Goliath protocol \cite{davidgoliath} should be
implemented as a component the implementation of this thesis can use. The
current implementation assumes a tamper--proof hardware token that implements
the OAFE functionality (the program \JWBtoken{} that comes with this thesis
implements the functionality naively but insecure).

% vim: set spell spelllang=en_us fileencoding=utf8 :
