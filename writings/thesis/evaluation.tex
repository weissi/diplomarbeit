\JWlone{Evaluation}
\label{sec:evaluation}

\JWltwo{Test Setup}
\label{sec:test-setup}

\JWlthree{Test Maschines}
\label{sec:test-machines}

Both test machines are regular home computer systems thus the benchmarks were
not run under laboratory conditions. Though, most background services and other
programs that could interfere with the benchmarks have been stopped. The
implementation has been compiled using full optimizations turned on
(\JWcmd{cabal configure --ghc-options=-O3}).


\JWlfour*{Test Maschine 1}

\emph{Dell Latitude D620} running \emph{Debian GNU/Linux} on kernel version
\emph{3.1.7, 32--bit}. The machine is powered by a \emph{Intel\TReg{} Core Duo
T2400} dual core processor at \emph{1.83 GHz}. It has \emph{2 GB} system memory.


\JWlfour*{Test Maschine 2}

\emph{Apple Mac mini} (\texttt{Macmini 3,1}) running \emph{MacOS X 10.7.5
(Lion), 64--bit}. The machine is powered by a \emph{Intel\TReg{} Core 2 Duo}
dual core processor at \emph{2.26 GHz}. It has \emph{8 GB} system memory.

\JWlthree{Test Setup}

Both machines run the three programs (\JWBpOne{}, \JWBpTwo{}, \JWBtoken{})
simultaneously, the programs are compiled single--threaded. The programs
communicate to each other using local TCP/IP networking. Chapter
\ref{sec:communication-channels} has a in depth description about the
communication that takes part in the implementation that comes with this thesis.
The running time includes the DRAC building and transmitting, the OAFE
configuration and the successful evaluation of a random polynomial. The
polynomial is evaluated using \emph{Horner's rule}\cite{cormen01}. The data
points in all figures and tables were obtained by taking taking the median of
running the same benchmark five times in a row (preceded by a non--accounted
warm--up run).


\JWltwo{Computational Complexity}
\label{sec:comp-complexity}

Ordinary evaluation of a polynomial of degree $n$ using \emph{Horner's rule} is
in $\Theta(n)$ \cite{cormen01}. Despite the complex technique presented in this
thesis the overall evaluation time is still in $\Theta(n)$. This is true for
both, the theoretical examination and the implementation. Figure
\ref{fig:poly-deg-t} and table \ref{tab:poly-deg-t} show this for the finite
field $\mathbb{F}_{97}$ (implementation from the \JWTLhaskellForMaths{}
package). The implementation for the field $\mathbb{F}_{2^{256}}$ does not seem
to perform in linear time, the cause is the unoptimal implementation and the
Haskell binding of the library used for the calculations in
$\mathbb{F}_{2^{256}}$. The problem is that the library includes a rather
complex routine for object destruction that takes most of the evaluation time.
The root of the problem is that functional languages prefer immutable
(unchangeable) objects with very fast construction/destruction and the C++
library that was interfaced is optimized for as few constructions/destructions
as possible and the use of mutable objects. The phenomenon that is observable
when using this library is that the garbage collector is taking up most of the
running time (up to $85\%$) waiting for the library destruction routine. For
high performance (such as the pure Haskell implementation for $\mathbb{F}_{97}$)
another library should be interfaced or developed entirely in Haskell, but this
is not the main concern of this thesis. For futher details see chapter
\ref{sec:finite-field-calcs}. For smaller degrees the current implementation for
$\mathbb{F}_{2^{256}}$ does perform in linear time. Figure
\ref{fig:poly-deg-t-small} and table \ref{tab:poly-deg-t-small} demonstrate
this. It is also noteworthy that the first test machine (see chapter
\ref{sec:test-machines}) outperforms the second test machine despite the
inferior hardware. The cause has not been investigated, a possible causes could
be that the 64--bit \JWTghc{} runtime seems to be slower (at least on Apple
Macs)\cite{lentczner11}.


% F97 vs. F2Pow256 and Linux vs. Mac
\begin{figure}[ht]
  \centering
  \input{images/poly-deg-t}
  \caption{Evaluation Time of Polynomial by Degree}
  \label{fig:poly-deg-t}
\end{figure}

\begin{table}[ht]
  \centering
  \begin{tabular}{|c|c|c|}
    Polynomial Degree & Running Time $\mathbb{F}_{97}$ [s] & Running Time
    $\mathbb{F}_{2^{256}}$ [s]\\
    %
    500 &  1.149  &   1.506 \\
    1000 &  2.585 &   3.962 \\
    1500 &  4.128 &   7.052 \\
    2000 &  5.346 &  10.790 \\
    2500 &  6.686 &  12.587 \\
    3000 &  7.826 &  17.119 \\
    3500 &  9.081 &  20.869 \\
    4000 & 10.384 &  26.382 \\
    4500 & 11.566 &  28.987 \\
    5000 & 12.834 &  33.315 \\
    5500 & 14.062 &  39.785 \\
    6000 & 15.133 &  45.736 \\
    6500 & 16.561 &  50.956 \\
    7000 & 17.721 &  55.640 \\
    7500 & 18.908 &  66.145 \\
    8000 & 20.236 &  73.173 \\
    8500 & 21.518 &  77.986 \\
    9000 & 22.855 &  83.969 \\
    9500 & 24.356 &  90.903 \\
    10000 & 25.650 & 100.269 \\
  \end{tabular}
  \caption{Evaluation Time of Polynomials by Degree on Test Machine 1}
  \label{tab:poly-deg-t}
\end{table}

\begin{figure}[ht]
  \centering
  \input{images/poly-deg-t-small}
  \caption{Evaluation Time of Polynomial (Smaller Degrees) on Test Machine 1}
  \label{fig:poly-deg-t-small}
\end{figure}

\begin{table}[ht]
  \centering
  \begin{tabular}{|c|c|}
    Polynomial Degree & Average Running Time [ms] \\
    0  & 68.4 \\
    10 &  80.2 \\
    20 & 101.2 \\
    30 & 121.6 \\
    40 & 142.6 \\
    50 & 160.8 \\
    60 & 183.0 \\
    70 & 208.0 \\
    80 & 232.2 \\
    90 & 258.4 \\
    100 & 280.4 \\
    110 & 307.2 \\
    120 & 321.2 \\
    130 & 347.2 \\
    140 & 372.8 \\
    150 & 402.6 \\
    160 & 429.4 \\
    170 & 470.8 \\
    180 & 484.4 \\
    190 & 508.0 \\
    200 & 527.8 \\
    210 & 563.8 \\
    220 & 601.6 \\
    230 & 606.8 \\
    240 & 640.0 \\
  \end{tabular}
  \caption{Evaluation Time of Polynomial (Smaller Degrees) on Test Machine 1}
  \label{tab:poly-deg-t-small}
\end{table}

\JWltwo{Unused Graphics}


\JWltwo{TODO}

\begin{JWtodoBox}

\begin{itemize}

\item Wie schnell ist die derzeitige Implementierung?

\item Wie groß kann das Polynom werden?

\end{itemize}

\end{JWtodoBox}

\JWltwo{Contribution}

\begin{JWtodoBox}

  \begin{itemize}

    \item OPE in $\Theta(n)$

    \item Square \& Multiply und beliebige Circuits möglich aber nicht
      implementiert.

  \end{itemize}

\end{JWtodoBox}


\JWltwo{What's left?}

\begin{JWtodoBox}

  \begin{itemize}

    \item Implementing David \& Goliath protocol. The implementation assumes
      it's already available.

    \item Better $\mathbb{F}_{2^{256}}$ implementation or find library

    \item Fully implement arbitrary circuits.

    \item Improve technique to be secure against actively corrupted Goliaths for
      arbitrary circuits. (Goliath kann überall affine Transformationen
      einbauen)

  \end{itemize}

\end{JWtodoBox}

% vim: set spell spelllang=en_us fileencoding=utf8 :
