\JWlone{Methodology}
\label{sec:methods}

%
% ILLUSTRATION
%
\JWltwo{Illustration}
\label{sec:illustration}

This chapter informally illustrates the key ideas and methods proposed by this
thesis. The following chapters contain a more formal bottom--up description that
is rather cumbersome to understand without grasping the overall picture.

The goal is to obliviously evaluate a polynomial by two mutual distrusting
parties. Informally, that means to evaluate a polynomial ($f(x) = \sum a_ix^i$)
where the first party chooses $f$ and the second party chooses $x$. It is
crucial that neither party learns the choice of the other party. The naive and
simple solution is to instruct a trusted third party to evaluate the
polynomial---provided by the first party---at the grid point $x$ provided by the
second party. Of course, this solution is just as simple as insecure because the
third party could reveal its secrets at any time.

The thesis expresses the general polynomial as affine functions that evaluate
parts of the complete function. The entirety of the affine functions exactly
represents the original polynomial. The process is based on dividing the input
polynomial into affine functions, because \JWdefn{Oblivious Affine Function
Evaluation} {OAFE} \cite{davidgoliath} are used as the main building block.
Every OAFE enables one party to choose an affine function that another party can
evaluate obliviously. The OAFE guarantees that the second party does not learn
the affine function and that the first party does not learn the node at which
the second party evaluated the function. Additionally OAFE guarantees every
linear function can only be evaluated once. To maintain the security property
for the input polynomial, neither party should be able to learn anything from
intermediate results.

The role both parties play differs heavily: The first party---usually named
\JWpOne{}---is in possession of the polynomial to evaluate and sets up the
OAFEs.  The second party---usually named \JWpTwo{}---is less powerful: It does
only evaluate entities issued by \JWpOne{} and uses the already configured
OAFEs. But in the end, only \JWpTwo{} obtains the result.  Since the OAFEs play
an important role, it is crucial to envision that every OAFE \JWpOne{} generates
can be evaluated by \JWpTwo{} only once. In other words, an OAFE enables some
party to evaluate an affine function at one node and guarantees that no further
evaluations are possible. To prevent a corrupted \JWpOne{} from intercepting
information when \JWpTwo{} evaluates one of the OAFEs, \JWpOne{} is forced to
commit itself to a finite number of OAFEs a priori. \JWpOne{} is also forced to
commit itself to all parameters for all OAFEs. The OAFE implementation from
Döttling, Kraschewski and Müller--Quade\cite{davidgoliath} realizes the OAFE
functionality on exactly one tamper--proof hardware token, that has to be
physically sent to the other party. Because the OAFE functionality realizes all
OAFEs together, \JWpOne{} needs to commit itself to the OAFE configuration a
priori. \JWpOne{} configures all OAFEs before \JWpTwo{} even starts the process.

All following steps will be performed by \JWpTwo{} alone, no further interaction
with \JWpOne{} is necessary. An honest \JWpTwo{} acts completely
deterministically and will receive the function's final evaluated value $f(x)$.
The following process dividing the function in smaller parts usually uses the
term \emph{(arithmetic) circuit}. The term circuit means a rooted evaluation
tree (e.g., figure \ref{fig:sample-poly}) of a function where the leaf nodes
contain values or inputs and the inner nodes---called (arithmetic) gates---do
arithmetic operations.

The approach pursued here is to divide the arithmetic circuit that equals the
overall function to smaller sub--circuits. Each sub--circuit can be composed of
arithmetic gates and other sub--circuits. \JWpTwo{} is commissioned to evaluate
each sub--circuit to an intermediate value. \JWpTwo{} then stores all
intermediate values since they are used to compute the following sub--circuits.
Whenever one sub--circuit $A$ contains a node that is another sub--circuit $B$,
this node gets replaced by the intermediate output value of $B$ before
evaluating $A$.  Obviously the intermediate values are a potential security
threat: A passively corrupted \JWpTwo{} could try to derive information from
these intermediate results. An actively corrupted \JWpTwo{} could additionally
try to modify the intermediate values and gain supplemental information out of
that. To not directly reveal the value of an evaluated sub--circuit the
intermediate values have to be \emph{encrypted}. To be able to identify an
illicit forgery the overall evaluation has to fail when an attacker tries to
illicitly modify an intermediate result. In this thesis, the intermediate values
are tuples of two values. The decryption of both values represents---when
well--formed---the same value. The gain of this technique is that an attacker
cannot change the value and preserve the well--formedness without knowing the
encryption keys. Any change to one (or both) tuple values causes the
intermediate value to be destroyed (formally represented as $\bot$). After
having evaluated the last sub--circuit, its resulting encrypted tuple undergoes
a special procedure revealing the unencrypted scalar result value. Details and
the formal description of the procedures mentioned above can be found in the
following chapters.

\begin{figure}[htb]
  \centering
  \includegraphics[width=10cm]{images/sample-polynomial.eps}
  \caption{Circuit encoding the polynomial $1 + 2x + 3x^2$ including its
    (sub--)circuits (dashed boxes)}
  \label{fig:sample-poly}
\end{figure}

The overall process is very straightforward: \JWpOne{} analyzes the polynomial
and transforms it into a circuit (the entire figure \ref{fig:sample-poly}). This
circuit is then divided to sub--circuits (the boxes bounded by dashed lines).
All the sub--circuits are then encoded in a way that \JWpTwo{} cannot learn
anything private to \JWpOne{}. To achieve that, \JWpOne{} sets up an OAFE and
hands the OAFE along with a description of the sub--circuits to \JWpTwo{}.
After sending the circuits and the OAFE functionality, \JWpOne{} can shut down
because it is no longer needed in the process. As soon as \JWpTwo{} receives the
sub--circuit description and the OAFEs, it starts the evaluation, one
sub--circuit after the other. To discuss the evaluation the sample polynomial $1
+ 2x + 3x^2$ (see figure \ref{fig:sample-poly}) is used in the following. In the
whole procedure, \JWpTwo{} should not learn the coefficients ($a_0$, $a_1$ and
$a_2$) of the polynomial $a_0 + a_1x + a_2x^2$ but is able to learn the degree
of the polynomial. The first step for \JWpTwo{} is to evaluate the sub--circuit
only containing $x$.  This is in fact only one sub--circuit that appears three
times in the figure.  The next step would be to evaluate the sub--circuit only
encoding $3$ (remember, not learning the value $3$!), then the sub--circuit
encoding $x^2 (= x \cdot x)$ and finally the overall circuit that encodes $1 +
2x + 3x^2$.  Usually and as in the example above, the sub--circuits are of
maximal size. Notably, a sub--circuit can only contain multiplications that only
depend on either constants or stored intermediate values.

To simplify the analysis of the different parts and to show the
modularity, special terms are used throughout in this thesis. A mapping from the
informal terms used above and the terms used otherwise (and defined in the
following chapters) follows:

In the informal illustration above, the encoded tuples played an important role.
They represented values and the sub--circuits evaluated to these encrypted
tuples. In fact, the sub--circuits are also twofold, they have a left and a
right side that eventually evaluate to two values: Both sides of the encrypted
tuple. For technical reasons, the two sides of the circuits and the tuples are
often handled apart. They still represent the same value encrypted with
different keys. For this reason the terms below all exist in two forms, the
\emph{Double} form (such as \emph{Double Randomized Affine Encoding}) and the
regular form (such as \emph{Randomized Affine Encoding}). At some point in the
processing, they are split syntactically, two regular entities are just the same
as one Double entity. The difference is mainly the same as naming tuple
$\widetilde{a} = (\widetilde{a_l}, \widetilde{a_r})$ \emph{Double Value} and
$\widetilde{a_l}$ and $\widetilde{a_r}$ \emph{Value}s.

\begin{itemize}

  \item The intermediate values that are encrypted twofold are named
    \emph{Double Randomized Affine Values} (DRAV), defined in chapter
    \ref{def:DRAV}.

  \item The encodings of sub--circuits are called \emph{Double Affine Randomized
    Encodings} (DRAE) and \emph{Randomized Affine Encodings} (RAE) defined in
    chapter \ref{def:DRAE}. Each (D)RAE is assigned to an intermediate variable
    that occurs in the subsequent (D)RAEs. A (D)RAE is a specification of
    calculations that have to be performed until obtaining the (D)RAEs result
    value. For the (D)RAC, the result value is just an intermediate
    value that a sub--circuit evaluated to.

  \item The overall circuit representing exactly one function is named
    \emph{Double Affine Randomized Circuit} (DRAC) or \emph{Affine Randomized
    Circuit} (RAC) defined in chapter \ref{def:DRAC}. A DRAC is the collectivity
    of DRAEs each assigned to intermediate variables storing their result
    values.

\end{itemize}


%
% DEFINITIONS
%
\JWltwo{Definitions}
\label{sec:rae-definitions}

This chapter defines important entities that are used in the following chapters.

% Field K
\JWlthree{Field $\mathbb{K}$}
\label{sec:field}

\label{def:field} Throughout this thesis, $\mathbb{K}$ represents an arbitrary
large finite field, such as $\mathbb{F}_{2^{256}}$.  When not mentioned
otherwise, this thesis assumes the field $\mathbb{F}_{2^{256}}$ specified by the
irreducible polynomial $1 + x^2 + x^5 + x^{10} + x^{256}$.


% OAFEs
\JWlthree{Oblivious Affine Function Evaluation}

The main building block of this thesis are \JWdef{Oblivious Affine Function
Evaluation}{OAFE}{s}. More precisely, \emph{Sequential one--time OAFE} as
defined by Döttling, Kraschewski and Müller--Quade \cite{davidgoliath}. The OAFE
functionality enables to sequentially evaluate $n$ affine functions specified a
priori. The OAFE functionality is implemented by the David \& Goliath protocol
\cite{davidgoliath} and exactly one stateful tamper--proof hardware token. In
other words, one party can specify $n$ affine functions and another party will
be able to sequentially evaluate the functions exactly once. The evaluating
party will only learn one evaluation of each function $f_i$ but not their
definition. After all $n$ functions have been evaluated the tamper--proof
hardware token can be physically destroyed.

\begin{align*}
  i \in& \{1, \ldots, n\}\\
%
  f_i(x_i) = &
  a_ix_i + b_i \\
%
  = &
\begin{pmatrix}a_{i,1}\\a_{i,2}\\a_{i,3}\\\vdots\end{pmatrix}x_i +
\begin{pmatrix}b_{i,1}\\b_{i,2}\\b_{i,3}\\\vdots\end{pmatrix}
\end{align*}

\noindent{}For the sake of simplicity, the term \emph{OAFE} is used slightly
different in this thesis: The term \emph{OAFE} is a functionality to evaluate
one affine function. The plural (\emph{OAFEs}) means a set of OAFEs that enable
to evaluate multiple affine functions. Therefore the collectivity of OAFEs as
defined in this thesis can be implemented by one \emph{Sequential one--time
OAFE} functionality as defined by Döttling, Kraschewski and Müller--Quade
\cite{davidgoliath}.


%
% DUAL RANDOMIZED AFFINE VALUES
%
\JWltwo{Dual Randomized Affine Values}
\label{sec:drav}

\JWdef{Dual Randomized Affine Value}{DRAV}{s} are encrypted, signed values
representing a scalar value of the field $\mathbb{K}$. Each DRAV is encrypted
with a pair of \emph{dual keys}. The first dual key, the \emph{static key},
remains the same in the whole DRAC (see chapter \ref{def:DRAC}) generation
procedure and is usually denoted as $(\alpha_l, \alpha_r)$. The second dual key,
the \emph{dynamic key} is a short--lived key, usually represented as $(\beta,
\beta')$. Two DRAVs only share the same dynamic key by chance but always share
the same static key. Encoding a regular value $v \in \mathbb{K}$ as a DRAV
$\widetilde{v}$ is straightforward: For the sake of simplicity this thesis
assumes a function $E(v)$ (also named \emph{universal encoding function}) that
is implicitly parametrized by the static dual key $(\alpha_l, \alpha_r)$ and is
able to generate a new dynamic dual key $(\beta, \beta')$ uniformly at random.
Just like $E(v)$, this thesis also assumes $D(\widetilde{v})$, named the
\emph{universal decoding function}. The universal decoding function is assumed
to be implicitly parametrized by the encryption keys from the context it is used
in. Both functions are defined below.  The universal encoding and decoding
functions only serve the purpose of describing the methodology. In the reality
especially the function $D$ is never called by anyone. That would not even be
possible since only the party in possession of the keys (\JWpOne{}) has the
information to do so but because of the non--interactivity of the protocol,
\JWpOne{} is not active anymore when the second party (not in possession of the
keys, usually named \JWpTwo{}) starts the evaluation. The real protocol encodes
the encryption and decryption into the OAFEs in a way that as soon as \JWpTwo{}
tries to cheat everything eventually becomes uniform randomness. To cheat means
to disrespect the protocol description and to misbehave in any way. The property
to turn everything to uniform randomness as soon as a party tries to cheat is
done using carefully chosen linear functions realized as OAFEs. The setup of
these linear functions assures the addition of uncorrelated uniform randomness
as soon as \JWpTwo{} tries to cheat. One can envision the process as applying a
one--time pad encryption that is only correctly removed if the other party did
not try to cheat. As soon as the second party tries to cheat this resembles the
attempt to undo a one--time pad encryption using another one--time pad. This
clearly leads to a one--time pad encryption which can only be undone using an
unknown one--time pad. The unknown one--time pad is a composition of the
encrypting one--time pad and the one--time pad using which the decryption was
attempted.

\begin{align}
  \label{eqn:one-time-pad}
  \hat{E}(v; \alpha_l, \alpha_r, \beta, \beta') &=
  (\alpha_l \cdot v + \beta, \alpha_r \cdot v + \beta')\\
  %
  E(v) &= \hat{E}(v; \alpha_l, \alpha_r, \beta, \beta') \qquad
  \text{(implicitly knowing the keys)}\nonumber
  %
\end{align}

\noindent{}The values $\beta$ and $\beta'$ are as mentioned above fresh values
uniformly at random. In finite fields $\beta$ and $\beta'$ therefore one--time
encrypt both tuple components, as such a DRAV is one--time pad encrypted.
$\alpha_l$ and $\alpha_r$ are also values uniformly at random but are in
contrast to $\beta$ and $\beta'$ used in for DRAVs throughout the whole
process. The purpose they serve will be discussed in the following chapters.

Notationally, the DRAV encoding a scalar value $v$ is usually denoted as
$\widetilde{v}$. $\widetilde{v}$'s tuple components are usually called
$\widetilde{v_l}$ and $\widetilde{v_r}$: $(\widetilde{v_l}, \widetilde{v_r}) =
\widetilde{v} = E(v)$. Where appropriate, DRAVs are also denoted in a vector
notation $\begin{pmatrix}\widetilde{v_l}\\\widetilde{v_r}\end{pmatrix}
\entspricht (\widetilde{v_l}, \widetilde{v_r}) = E(v)$. The universal decoding
function $D(\widetilde{v})$ is:

\begin{align}
  %
  \hat{D}(\widetilde{v}; \alpha_l, \alpha_r, \beta, \beta') &=
  \begin{pmatrix}
    \frac{\widetilde{v_l} - \beta}{\alpha_l}\\
    \frac{\widetilde{v_r} - \beta'}{\alpha_r}
  \end{pmatrix} \nonumber\\
  %
  \label{eqn:keys-assumed}
\begin{pmatrix}D_l(\widetilde{v})\\D_r(\widetilde{v})\end{pmatrix} &=
  \hat{D}(\widetilde{v}; \alpha_l, \alpha_r, \beta, \beta') \qquad
  \text{(implicitly knowing the keys)}\\
  %
  D(\widetilde{v}) &=
  \left\{
    \begin{array}{l l}
      D_l(\widetilde{v}) & \quad
      \text{if}~D_l(\widetilde{v}) = D_r(\widetilde{v})\\
      \bot & \quad \text{otherwise ($\widetilde{v}$ is non--well--formed)}\\
    \end{array}\right.\nonumber
    %
\end{align}

\noindent{}In equation \ref{eqn:keys-assumed} one can see that the universal
decoding function $D$ assumes context--specific  dual keys $(\alpha_l,
\alpha_r)$ and $(\beta, \beta')$. If an attacker at some point passes a DRAV
that is not expected to be decoded at this point, the decoding will fail and
evaluate to $\bot$. This is evident because $D$ will decode using the dual keys
of the DRAV that was expected to be decoded (see also Lemma
\ref{lem:well-formed-fun-of-dec-fun}).

\begin{lem}
  \label{lem:DRAV-random}

  A party that is not in possession of the encryption (dual) keys will not learn
  anything from a DRAV\@. A DRAV is a tuple consisting of two values uniformly
  at random that is uncorrelated to any other DRAV\@.

\end{lem}
\begin{proof}

  In a finite field, the addition of some value $r$ uniformly at random to
  another value $x \in \mathbb{K}$ is uniformly at random. Therefore $\alpha_l
  \cdot v + \beta$ and $\alpha_r \cdot v + \beta'$ are two values uniformly at
  random if and only if $\beta$ and $\beta'$ are uniformly at random. Per
  definition, every time a DRAV gets encoded, $\beta$ and $\beta'$ are fresh
  uniformly distributed random values. Trivially, a DRAV is therefore
  uncorrelated to any other DRAV\@.

\end{proof}


% WELL-FORMED DRAVs
\JWlthree{Well--Formed DRAVs}
\label{sec:well-formed-DRAV}

A DRAV $\widetilde{v}$ is well--formed iff $D(\widetilde{v}) \neq \bot
\Leftrightarrow D_l(\widetilde{v}) = D_r(\widetilde{v})$. Therefore, if
$D(\widetilde{\chi}) = \bot$, $\chi$ is non--well--formed. Obviously the
well--formedness of a DRAV depends on the encryption keys used to decrypt.
Decoding well--formed DRAVs using any other decoding function will highly likely
lead to $\bot$ because the well--formed DRAV looks non--well--formed to the
other decoding function. Decoding using another decoding does not lead to
$\bot$, iff both DRAVs have the same encryption keys. The probability is
therefore $\frac{1}{2*|\mathbb{K}|}$, $\mathbb{K}$ (see chapter \ref{sec:field}
being the finite field and $|\mathbb{K}|$ its size.

\begin{lem}
  \label{lem:well-formed-fun-of-dec-fun}

  DRAV well--formedness is a function of the keys used to decrypt it.

\end{lem}
\begin{proof}

  Assuming two well--formed DRAVs $\widetilde{a}$ and $\widetilde{b}$. Both
  DRAVs have their respective decoding function $D^a$ and $D^b$ and their
  dynamic dual key (say $(\beta_1, \beta_2)$ for $\widetilde{a}$ and
  $(\beta_3, \beta_4)$ for $\widetilde{b}$). The following equations show
  the decoding of the DRAVs $\widetilde{a}$ and $\widetilde{b}$ with the correct
  keys and the wrong keys.

  \begin{align*}
    %
    D^a(\widetilde{a}) &= D(\widetilde{a}) \qquad\text{(using $\widetilde{a}$'s
    keys)}\\
    %
    D^b(\widetilde{b}) &= D(\widetilde{b}) \qquad\text{(using $\widetilde{b}$'s
    keys)}\\
    %
    a &= D^a(\widetilde{a}) \entspricht
    \begin{pmatrix}
      \frac{(\alpha_l \cdot a + \beta_1) - \beta_1}{\alpha_l}\\
      \frac{(\alpha_r \cdot a + \beta_2) - \beta_2}{\alpha_r}\\
    \end{pmatrix}
    = a\\
    %
    a' &= D^a(\widetilde{b}')
    \entspricht
    \begin{pmatrix}
      \frac{(\alpha_l \cdot b + \beta_3) - \beta_1}{\alpha_l}\\
      \frac{(\alpha_r \cdot b + \beta_4) - \beta_2}{\alpha_r}\\
    \end{pmatrix}
    \entspricht
    \begin{pmatrix}
      b +
      \frac{\beta_3 - \beta_1}{\alpha_l}\\
      b +
      \frac{\beta_4 - \beta_2}{\alpha_r}\\
    \end{pmatrix}
    \stackrel{*}{=} \bot\\
    %
    b &= D^b(\widetilde{b}) \entspricht
    \begin{pmatrix}
      \frac{(\alpha_l \cdot b + \beta_3) - \beta_3}{\alpha_l}\\
      \frac{(\alpha_r \cdot b + \beta_4) - \beta_4}{\alpha_r}\\
    \end{pmatrix}
    = b\\
    %
    b' &= D^b(\widetilde{a}')
    \entspricht
    \begin{pmatrix}
      \frac{(\alpha_l \cdot a + \beta_1) - \beta_3}{\alpha_l}\\
      \frac{(\alpha_r \cdot a + \beta_2) - \beta_4}{\alpha_r}\\
    \end{pmatrix}
    \entspricht
    \begin{pmatrix}
      a +
      \frac{\beta_1 - \beta_3}{\alpha_l}\\
      a +
      \frac{\beta_2 - \beta_4}{\alpha_r}\\
    \end{pmatrix}
    \stackrel{*}{=} \bot\\
    %
    &\JWnegl{}
  \end{align*}

  \noindent{}As shown above, decoding a well--formed DRAV using the wrong
  decoding function leads to $\bot$.

\end{proof}


\begin{lem}
  \label{lem:DRAV-indistinguishable}

  Without knowing the encryption keys, a non--well--formed DRAV is
  indistinguishable from a well--formed DRAV\@.

\end{lem}
\begin{proof}

  From Lemma \ref{lem:DRAV-random} we learn, that a well--formed DRAV only
  consists of two values uniformly at random. From Lemma
  \ref{lem:well-formed-fun-of-dec-fun} we learn, that well--formedness is a
  function of the encryption keys used to eventually decrypt the DRAV\@. Since a
  party that is not in possession of the encryption keys cannot know the
  decryption function, well--formed and non--well--formed DRAVs are
  indistinguishable for a party not in possession of the keys.

\end{proof}


% DIRECT DRAV ARITHMETIC
\JWlthree{Direct DRAV Addition}
\label{sec:DRAV-addition}

This thesis refers to DRAV addition as \emph{direct DRAV addition} because it
has the property to be performable without knowledge of a DRAV's encryption
keys. But (see Lemma \ref{lem:wrong-add}) the addition of DRAVs does not lead to
additional information. Although addition can be performed without the knowledge
of the encryption keys, it will not reveal additional information because the
encryption keys automatically changes. Therefore, the result will only be
well--formed iff the addition was intended by the party in possession of the
keys (see Lemma \ref{lem:well-formed-fun-of-dec-fun}).

\begin{lem}
  \label{lem:DRAV-add}

Additions commissioned by a party in possession of the encryption keys of
well--formed DRAVs lead to well--formed DRAV: $\widetilde{x} =
(\widetilde{x_l}, \widetilde{x_r})$ and $\widetilde{y} = (\widetilde{y_l},
\widetilde{y_r})$ can be added component--wise to $\widetilde{z} =
\left(\widetilde{x_1} + \widetilde{y_1}, \widetilde{x_2} +
\widetilde{y_2}\right)$. The encryption keys for $\widetilde{z}$ will be
$(\alpha_l, \alpha_r)$ and $(\beta_1 + \beta_3, \beta_2 + \beta_4)$ assuming
$\widetilde{x}$ was encrypted with $(\alpha_l, \alpha_r)$ and $(\beta_1,
\beta_2)$ and $y$ was encrypted with $(\alpha_l, \alpha_r)$ and $(\beta_3,
\beta_4)$.

\end{lem}
\begin{proof}

From ($\widetilde{x} = \left(\alpha_l \cdot x + \beta_1,
\alpha_r \cdot x + \beta_2\right)$, $\widetilde{y} = \left(\alpha_l \cdot x +
\beta_3, \alpha_r \cdot x + \beta_4\right)$) it is obvious that: $\widetilde{z}
= \left(\alpha_l \cdot (x+y) + (\beta_1 + \beta_3), \alpha_r \cdot (x+y) +
(\beta_2 + \beta_4)\right)$ and $\widetilde{z}$ is well--formed.

\end{proof}

\begin{lem}
  \label{lem:DRAV-add-bad}

The addition of two DRAV leads to a non--well--formed DRAV if at least one
operand DRAV is non--well--formed. It is of particular interest the following
property holds: $\forall \widetilde{x}: \widetilde{x} + \bot = \bot +
\widetilde{x} = \bot$.

\end{lem}
\begin{proof}

Let $\widetilde{\chi}$ be a non--well--formed DRAV, so: $\widetilde{\chi} =
(\alpha_l \cdot \chi + \beta_3 + \Delta_l, \alpha_r \cdot \chi + \beta_4 +
\Delta_r)$. The component--wise addition $\widetilde{\nu}$ of $\widetilde{\chi}$
to any well--formed $\widetilde{x} = (\alpha_l \cdot x + \beta_1, \alpha_r \cdot
x + \beta_2)$ is $\widetilde{\nu} = (\alpha_l \cdot (x+\chi) + (\beta_1+\beta_3)
+ \Delta_l, \alpha_r \cdot (x+\chi) + (\beta_2+\beta_4) + \Delta_r)$.  Using the
component--wise universal decoding functions $D_l(\widetilde{v})$ and
$D_r(\widetilde{v})$ (see chapter \ref{def:DRAV}), the value of $\chi$ is $\chi
= (D_l(\widetilde{\chi_l}), D_r(\widetilde{\chi_r})) = (x + \chi +
\frac{\Delta_l}{\alpha_l}, x + \chi + \frac{\Delta_r}{\alpha_r})$. So: $\forall
(\Delta_r, \Delta_l) \in \mathbb{K} \setminus \{(0, 0)\} \wedge
\frac{\Delta_l}{\alpha_l} \neq \frac{\Delta_r}{\alpha_r}: D(\widetilde{\chi}) =
\bot$. Since the encryption keys are not known to an attacker,
$\frac{\Delta_l}{\alpha_l} \neq \frac{\Delta_r}{\alpha_r}$ holds except for a
negligible probability if $\Delta_r \neq 0 \vee \Delta_r \neq 0$ and that's the
property for being forged (non--well--formed) which was the assumption.
Trivially $\bot + \bot = \bot$ by a similar argument.

\end{proof}


\begin{lem}
  \label{lem:wrong-add}

  An addition that was unintended by a party in possession of the encryption
  keys will not reveal additional information. In other words: A party that is
  not in possession of the keys but that knows three well--formed DRAVs
  $\widetilde{a}$, $\widetilde{b}$ and $\widetilde{c}$ and is commissioned to
  execute the addition $\widetilde{y} = \widetilde{a} + \widetilde{b}$ cannot
  generate a well--formed DRAV $\widetilde{y}' = \widetilde{a} + \widetilde{c}$.

\end{lem}

\begin{proof}

  Since every DRAV has per definition different dynamic keys the
  component--wise addition of two DRAVs leads to a new dynamic key that is
  characteristic for the addition intended by a party in possession of the
  encryption keys.

  Assuming three well--formed DRAVs $\widetilde{a}$, $\widetilde{b}$ and
  $\widetilde{c}$ and the party in possession of the keys commissions any other
  party to execute $\widetilde{y} = \widetilde{a} + \widetilde{b}$ but the other
  party tries to illicitly execute $\widetilde{y}' = \widetilde{a} +
  \widetilde{c}$:

  \begin{align*}
    %
    \widetilde{a} &=
    \begin{pmatrix}
      \alpha_l \cdot a + \beta_1\\
      \alpha_r \cdot a + \beta_2
    \end{pmatrix}\\
    %
    \widetilde{b} &=
    \begin{pmatrix}
      \alpha_l \cdot b + \beta_3\\
      \alpha_r \cdot b + \beta_4
    \end{pmatrix}\\
    %
    \widetilde{c} &=
    \begin{pmatrix}
      \alpha_l \cdot c + \beta_5\\
      \alpha_r \cdot c + \beta_6
    \end{pmatrix}\\
    %
    \widetilde{y} &=
    \begin{pmatrix}
      \alpha_l \cdot a + \beta_1 + \alpha_l \cdot b + \beta_3\\
      \alpha_r \cdot a + \beta_2 + \alpha_r \cdot b + \beta_4\\
    \end{pmatrix} =
    \begin{pmatrix}
      \alpha_l \cdot (a+b) + (\beta_1 + \beta_3)\\
      \alpha_r \cdot (a+b) + (\beta_2 + \beta_4)\\
    \end{pmatrix}\\
    %
    \widetilde{y}' &=
    \begin{pmatrix}
      \alpha_l \cdot a + \beta_1 + \alpha_l \cdot c + \beta_5\\
      \alpha_r \cdot a + \beta_2 + \alpha_r \cdot c + \beta_6\\
    \end{pmatrix} =
    \begin{pmatrix}
      \alpha_l \cdot (a+c) + (\beta_1 + \beta_5)\\
      \alpha_r \cdot (a+c) + (\beta_2 + \beta_6)\\
    \end{pmatrix}\\
    %
  \end{align*}

  As soon as the party in possession of the keys tries to decode using the
  encryption keys for $\widetilde{y}$ the result (either $\widetilde{y}$ or
  $\widetilde{y}'$) the other party will get caught if it tried to cheat:

  \begin{align*}
    %
    D^y(\widetilde{y}) &= D(y) \qquad\text{(using $y$'s encryption keys)}\\
    %
    y &= D^y(\widetilde{y}) \entspricht
    \begin{pmatrix}
      \frac{(\alpha_l \cdot (a+b) + (\beta_1 + \beta_3)) - (\beta_1+\beta_3)}
           {\alpha_l}\\
      \frac{(\alpha_r \cdot (a+b) + (\beta_2 + \beta_4)) - (\beta_2+\beta_4)}
           {\alpha_r}\\
    \end{pmatrix}
    = a+b\\
    %
    y' &= D^y(\widetilde{y}')
    \entspricht
    \begin{pmatrix}
      \frac{(\alpha_l \cdot (a+b) + (\beta_1 + \beta_5)) - (\beta_1+\beta_3)}
           {\alpha_l}\\
      \frac{(\alpha_r \cdot (a+b) + (\beta_2 + \beta_6)) - (\beta_2+\beta_4)}
           {\alpha_r}\\
    \end{pmatrix}
    \entspricht
    \begin{pmatrix}
      (a+b) +
      \frac{\beta_5 - \beta_3}{\alpha_l}\\
      (a+b) +
      \frac{\beta_6 - \beta_4}{\alpha_r}\\
    \end{pmatrix}
    \stackrel{*}{=} \bot\\
    %
    &\JWnegl{}
  \end{align*}
\end{proof}


% FINAL DRAV DECODING
\JWlthree{Final DRAV Decoding}
\label{sec:drav-final-decoding}

Finally decoding a DRAV means to extract the hidden value which is crucial
because otherwise everything else would be useless. It can be trivially done
using the universal decoding function $D(\widetilde{v})$. But as the encryption
keys, $D$ is not available to ordinary parties. This chapter describes a system
that enables the party in possession of the keys to allow other parties to
decode a specific DRAV\@. Usually it only allows the final DRAV to be decoded,
otherwise intermediate information would leak.

The overall costs thereof are only one addition and an OAFE evaluation for the
ordinary party. Of course, the OAFE has to be created by the party that knows
the encryption keys. The setup of this OAFE can be seen as the authorization to
decode exactly one specific DRAV\@. The procedure will decode a DRAV to a final
scalar value although $D$ is a partial function. The special value $\bot$ that
$D$ evaluates to if the DRAV is non--well--formed is mapped to uniform
randomness. As Lemma \ref{lem:well-formed-fun-of-dec-fun} proofs, a DRAV is
also non--well--formed if the encryption keys differ from the keys of the DRAV
whose decoding was intended. Therefore, no other DRAVs can be decoded
illegitimately. In the following, the DRAV to be decoded is named $\widetilde{v}
= (\widetilde{v_l}, \widetilde{v_r})$ and the OAFE permitting the decoding is
called the \emph{final OAFE}.

The second party's input to the final OAFE is $\widehat{v} = \widetilde{v_l} +
\widetilde{v_r}$, the addition of both components of the DRAV to decode.  The
final OAFE was created by the first party as follows: Assuming $\widetilde{v}$
is encrypted with $(\alpha_l, \alpha_r)$ and $(\beta_1, \beta_2)$, the first
party knows $\widehat{v}$ has to be encrypted using $(\alpha_l + \alpha_r)$ and
$(\beta_1 + \beta_2)$.  Given this knowledge the final OAFE setup is
$\frac{1}{\alpha_l + \alpha_r} \cdot \widehat{v} - \frac{\beta_1 +
\beta_2}{\alpha_l + \alpha_r}$.

Again, an attacker must be caught when trying to forge a DRAV ($D(\widetilde{v})
= \bot$ if $\widetilde{v}$ has been forged, $\bot$ is mapped to uniform
randomness in this process since an OAFE has no $\bot$--value). If the attacker
cheated somewhere in the process and forged one of the DRAV tuples
$\widetilde{x} = (\widetilde{x_1}, \widetilde{x_2})$ to $\widetilde{x'} =
(\widetilde{x_1} + \Delta_1, \widetilde{x_2} + \Delta_2)$, the DRAV
$\widetilde{x'}$ becomes---except for a negligible
probability---non--well--formed (see section \ref{sec:drav}). The result is that
the decoded result will become uniform randomness (assuming $\widetilde{x}$ is
forged to $\widetilde{x'_1} = \widetilde{x_1} + \Delta_1$ and $\widetilde{x'_2}
= \widetilde{x_2} + \Delta_2$):

\begin{align*}
  \widehat{x'} = & \widetilde{x'_1} + \widetilde{x'_2} = \widetilde{x_1} +
  \Delta_1 + \widetilde{x_2} + \Delta_2 \\
  %
  \Rightarrow x' = & \frac{1}{\alpha_l + \alpha_r} \cdot \widehat{x'} -
  \frac{\beta_{x_1} +
  \beta_{x_2}}{\alpha_l + \alpha_r} \\
  %
  \Leftrightarrow x' = & \frac{\widetilde{x_1} + \Delta_1 +
  \widetilde{x_2} + \Delta_2}{\alpha_l + \alpha_r} -
  \frac{\beta_{x_1} +\beta_{x_2}}{\alpha_l + \alpha_r}\\
  %
  \Leftrightarrow x' = & \frac{(\alpha_l x + \beta_{x_1}) + \Delta_1 +
  (\alpha_r x + \beta_{x_2}) + \Delta_2}{\alpha_r + \alpha_l} -
  \frac{\beta_{x_1} +\beta_{x_2}}{\alpha_l + \alpha_r} \\
  %
  \Leftrightarrow x' = & \frac{(\alpha_l+\alpha_r)x + (\beta_{x_1}+\beta_{x_2} +
  \Delta_1+\Delta_2)}{\alpha_l+\alpha_r} -
  \frac{\beta_{x_1} +\beta_{x_2}}{\alpha_l + \alpha_r} \\
  %
  \Leftrightarrow x' = & x + \frac{\beta_{x_1}+\beta_{x_2}}{\alpha_l+\alpha_r}
  + \frac{\Delta_1 + \Delta_2}{\alpha_l + \alpha_r} -
  \frac{\beta_{x_1}+\beta_{x_2}}{\alpha_l + \alpha_r} \\
  %
  \Leftrightarrow x' = & x + \frac{\Delta_1 + \Delta_2}{\alpha_l + \alpha_r}\\
\end{align*}

Because an attacker is not in possession of the static encryption keys
$\alpha_l$ and $\alpha_r$, it cannot control the value of $\frac{\Delta_1 +
\Delta_2}{\alpha_l + \alpha_r}$. Since $\alpha_l$ and $\alpha_r$ are chosen
uniformly at random, the result $x'$ becomes uniformly at random, too. An
attacker could choose $\Delta_l + \Delta_r = 0$ but because the value that gets
passed to the OAFE is the addition of both values, $\Delta_l + \Delta_r = 0$ is
honest behavior.


%
% DUAL RANDOMIZED AFFINE ENCODING
%
\JWltwo{Dual Randomized Affine Encoding}
\label{sec:drae}

\JWdef{Dual Randomized Affine Encoding}{DRAE}{s} are affine representations of
parts of arithmetic circuits. A DRAE describes arithmetic expressions as affine
functions without revealing the original expression. A single DRAE alone is not
powerful enough to describe arbitrary complex arithmetic expressions, therefore
chapter \ref{def:DRAC} proposes a procedure to evaluate arbitrary expression
using multiple DRAEs. Technically, a DRAE is a specification of calculations
that need to be performed to eventually obtain the evaluated value of the
arithmetic expression. The reason for using DRAEs instead of evaluating the
arithmetic expressions as usual is that a DRAE operates on encrypted values.
Both, the input values and the output value of a DRAE are DRAVs (see chapter
\ref{def:DRAV}). Additionally, the arithmetic expression performed is hidden
from every party that is not in possession of the encryption keys. The reason
DRAEs specify the calculations using affine functions is that OAFEs provide
a secure way to obliviously evaluate affine functions. The procedure of
evaluating arithmetic expression using DRAEs works as follows: The first party
that is in possession of the encryption keys chooses the expression to evaluate.
Next, it sets up the DRAE but hides the affine calculations inside OAFEs. In
fact, instead of the affine calculations themselves, the DRAEs specifies
references to the OAFEs that were configured to evaluate these functions
obliviously. The evaluating party finally evaluates the DRAEs with the help of
the OAFEs provided by the first party.

To easily envision the role of DRAEs and DRAVs: By performing arithmetic
operations on DRAVs a DRAE evaluates an arithmetic expression to a resulting
DRAV\@. Just the same way, an arithmetic expression performs operations on
values and evaluates to a result value (e.g., given $x=17$ and $y=23$, the
arithmetic expression $x*y + 3$ evaluates to $394$).

Summing up, DRAE evaluation is partitioning calculations between the two
parties: The first that builds the DRAE and sets up the OAFEs and the second
that provides the input and does the evaluation. In fact, the first party is not
directly involved in the evaluation process, it provided its calculations a
priori hidden inside OAFEs. But as stated above, one DRAE cannot realize
arbitrary complex arithmetic expressions, as a rule of thumb: As soon as a
(non--trivial) multiplication is part of the original arithmetic, one DRAE is
not enough to evaluate it.

The next chapters describe in depth how arithmetic operations can be safely
encoded and how a DRAE describes this encoding. Since DRAEs evaluate to DRAVs
and DRAVs can be easily added (see chapter \ref{sec:DRAV-addition}), DRAE
addition is easy, too: A DRAE that encodes the addition of two DRAEs can be
built practically costless. But DRAE multiplication is more complex: To multiply
two DRAEs, both DRAEs have to be evaluated separately, their results have to be
assigned to intermediate variables and a third DRAE has to be built that solely
multiplies the intermediate variables. In contrast to general DRAE
multiplication, a DRAE can encode the multiplication of two DRAVs and assigning
intermediate values to variables is just giving intermediate DRAVs a temporary
name.


% ADDITION
\JWlthree{Encoding Additions}
\label{sec:enc-adds}

Since two DRAVs can directly be added as explained in chapter
\ref{sec:DRAV-addition}, two DRAEs can be added by adding the constants and
unifying the multiplicative ($M$ in relations \ref{rel:DRAE} and
\ref{rel:pre-eval-DRAE}) and additive ($A$) terms. Notably, although the
encryption keys change, this operation can be performed by any party, in
possession of the encryption keys or not. Similarly to DRAVs, unintended
operations ruin the information because the encryption keys change when
performing operations. Operations unintended by the party in possession of the
keys lead to non--well--formed DRAVs because wrong encryption keys will be used
to decode them.


% MULTIPLICATION
\JWlthree{Encoding Multiplications}
\label{sec:enc-muls}

Since neither a DRAV (chapter \ref{def:DRAV}) nor a DRAE (see above) can be
multiplied directly, most multiplications have to be performed using a
construction involving additional DRAEs and intermediate variables holding
DRAVs. Chapter \ref{def:DRAC} describes the transformation of arbitrary
arithmetic expressions. This chapter describes multiplications that can directly
be expressed as a DRAE: A single multiplication of two DRAVs $\widetilde{x}$ and
$\widetilde{y}$ (each assigned to a variable) to a DRAE $E \in \mathcal{E}$.


% Towards Secure Multiplications
\JWlfour{Towards Secure Multiplications}
\label{sec:toward-sec-muls}

This chapter describes the iterations this thesis made until reaching the goal
of secure multiplications. The description is from ground up, it starts with
basic finite field mathematics, without DRAVs and DRAEs that will be introduced
differently in the process.

\paragraph{The general construction} is inspired by the paper \emph{How to
Garble Arithmetic Circuits} \cite{gac2012}. After the description of the
construction, the extensions that were developed for this thesis will be
described.

\begin{align*}
  %
\begin{pmatrix}\mathfrak{A}\\\mathfrak{C}\end{pmatrix} & =
\begin{pmatrix}1\\r_2\end{pmatrix} \cdot x +
\begin{pmatrix}-r_1\\-r_1r_2+r_3\end{pmatrix} &
  %
\begin{pmatrix}\mathfrak{B}\\\mathfrak{D}\end{pmatrix} & =
\begin{pmatrix}1\\r_1\end{pmatrix} \cdot y +
\begin{pmatrix}-r_2\\-r_3\end{pmatrix}\\
  %
  z & = \mathfrak{A} \cdot \mathfrak{B} + \mathfrak{C} + \mathfrak{D} =
  x \cdot y\\
\end{align*}

For uniformly random numbers $r1, r2, r3, r4 \in \mathbb{K}$ all the terms
$\mathfrak{A}$, $\mathfrak{B}$, $\mathfrak{C}$, and $\mathfrak{D}$ can be
calculated using two OAFEs and every term alone does not reveal any information
because each is one--time encrypted. But their composition ($\mathfrak{A} \cdot
\mathfrak{B} + \mathfrak{C} + \mathfrak{D}$) evaluates to the desired result $x
\cdot y$. Because of the one--time encryption, a simple two party evaluation
could be realized easily by calculating $\mathfrak{A}$ and $\mathfrak{C}$ or
$\mathfrak{B}$ and $\mathfrak{D}$ a priori and delivering the terms to the other
party. Using one OAFE configured by the first party, the second party is then
able to calculate the other terms and therefore the result $x \cdot y$. This
construction is not yet feasible for composable computations because the second
party learns the result of intermediate calculations. This flaw can be removed
by simple modifications.


\paragraph{Encrypted Variables} are introduced not to reveal intermediate
calculations. The basic idea is to have bar variables $\bar{x}$, an encrypted
form of $x$. Usually, $x$ is encrypted (boxed) as $\bar{x} = \alpha x + \beta$.
For the sake of simplicity, two functions $B(x) = \alpha x + \beta = \bar{x}$
and $U(\bar{x}) = (\bar{x}-\beta)*(1/\alpha)$ are assumed that box and unbox
variables by implicitly generating/knowing the encryption keys $\alpha$ and
$\beta$ from the context. Using the encrypted form, the multiplication above can
be revised, the first step is to encrypt the input variables $x$ and $y$.

\begin{align*}
  %
  \bar{x} & = B(x) = \alpha_x x + \beta_x &
  \bar{y} & = B(x) = \alpha_x y + \beta_y \\
  %
\begin{pmatrix}\mathfrak{A}\\\mathfrak{C}\end{pmatrix} & =
\begin{pmatrix}\alpha_z\\\alpha_z r_2\end{pmatrix} \cdot U(\bar{x}) +
\begin{pmatrix}-r_1\\-r_1r_2+r_3+\beta_z\end{pmatrix} &
  %
\begin{pmatrix}\mathfrak{B}\\\mathfrak{D}\end{pmatrix} & =
\begin{pmatrix}1\\r_1\end{pmatrix} \cdot U(\bar{y}) +
\begin{pmatrix}-r_2\\-r_3\end{pmatrix}\\
  %
  \bar{z} & = \mathfrak{A} \cdot \mathfrak{B} + \mathfrak{C} + \mathfrak{D} \\
  & = B(U(x) \cdot U(y)) = \alpha_z xy + \beta_z\\
\end{align*}

Because the composition of affine functions leads to affine functions as well,
every calculation above can be evaluated using OAFEs. The calculations above
need four OAFEs, two to encrypt the inputs $x$ and $y$ and two for the
multiplication $x \cdot y$. The first party which generated the OAFEs and chose
the random numbers in named \emph{Goliath} in the following. The party which
performs the evaluation but has no knowledge of the encryption keys is named
\emph{David}. Again, $\alpha_x, \alpha_y, \alpha_z, \beta_x, \beta_y, \beta_z,
r_1, r_2, r_3 \in \mathbb{K}$ and uniformly at random. Obviously the $\alpha$s
have to be invertible. After the multiplication, $\bar{z}$ is encrypted using
the encryption keys $\alpha_z$ and $\beta_z$. For two party calculations,
Goliath can evaluate the terms depending on $x$ (or $y$) the same way (without
using OAFEs) and transfer the evaluated terms to David. Given the OAFEs and the
terms Goliath evaluated a priori, David can then calculate the other
expressions, depending on its input. By commissioning additional tasks to David,
this construction is composable: When David can be instructed to store
(encrypted) intermediate values that it provides in further calculations,
arbitrary multiplicative expressions can be modeled with this construction.
Exemplary, the evaluation of the expression $(x \cdot y) \cdot z$ is discussed.
Assuming David provides $x$ and Goliath provides $y$ and $z$, the expression can
be evaluated by first boxing David's input $\bar{x} = B(x)$ using one OAFE.
Using the construction described above, David can now calculate the encrypted
intermediate result $\bar{t} = B(x \cdot y)$ without knowing anything about $y$
or the intermediate result $t$. Both one--time encrypted (boxed) variables. In
the next step, David can be commissioned to calculate $\bar{o} = E(t \cdot z$
similarly.  And $\bar{o}$ is the final result. Using one additional OAFE,
Goliath can allow David to execute $o = U(\bar{o})$ yielding the result of $o =
(x \cdot y) \cdot z$.  David will not learn anything from $y$, $t$ or $z$ that
it cannot calculate from $o$ (and his input $x$) directly. David could try to
forge the value of $\bar{t}$ before calculating $\bar{t} \cdot \bar{z}$ but
because it has no information about the encryption keys of $\bar{t}$ or
$\bar{z}$ it will render $o = U(\bar{o})$ to randomness because it will contain
random terms depending on some encryption key ($\forall \bar{v} \in \{B(v) \mid
v \in \mathbb{K}\}, \Delta \in \mathbb{K} \setminus \{0\}: U(\bar{v}+\Delta)
\neq U(\bar{v})+\Delta$). However, there is a security flaw: Usually, from $o =
(x \cdot y) \cdot z = 0$, David can learn $x = 0 \vee y = 0 \vee z = 0$. Because
$x$ is its own input, when knowing $x \neq 0$ from $o = 0$ it should learn $y =
0 \vee z = 0$. Unfortunately, David could choose $\bar{t}$ randomly and with
overwhelming probability, $U(\bar{t}) \neq 0$. So forging $\bar{t}$ to a random
number will reveal additional information to David: $o = 0 \Rightarrow U(\bar{t}
\cdot \bar{z}) = 0 \Rightarrow z = 0$ with overwhelming probability. This means
David does not know what it changes when it forges, but it can reveal additional
information when the result of a multiplication is $0$. Therefore, this thesis
underwent the next iteration.

\paragraph{Using Message Authentication Codes} illicit modifications can be
prevented. The original proposal of Carter and Wegman\cite{carter79} to hash
integers is to choose a prime $p$ (and random keys $a \neq 0$ and $b$) and use

\begin{align*}
  %
  h_{a,b}(x) = ((ax + b) \bmod p) \bmod m
  %
\end{align*}

In finite fields (such as $\mathbb{K}$) the modulus can be removed and the
hashing function can be adapted to $h_{a,b}(x) = (ax + b)$ being an universal
hashing function. For $a$s and $b$s only used once, the hashing function is a
one--time encryption as well. Because this thesis used $\bar{x} = B(x) = \alpha
x + \beta$ with fresh $\alpha$s and $\beta$s for every variable, this is an
one--time a one--time encryption of $x$. Because of the flaw that additional
information can be revealed when multiplications result in $0$, this iteration
replaces boxed values by DRAVs (chapter \ref{def:DRAV}). DRAVs are twofold
one--time encryptions, which are valid if the decryption of the one--time
encryptions equal. Therefore DRAVs are encrypted values with \JWdef{Message
Authentication Code}{MAC}{s} build--in. To be able to multiply two DRAVs, the
multiplication construction is adapted (for the exact definitions of DRAVs, see
chapter \ref{def:DRAV}):

\begin{align*}
  %
  \widetilde{x} & = E(x) = (\alpha_l x + \beta_1, \alpha_r x + \beta_2) &
  \widetilde{y} & = E(x) = (\alpha_l y + \beta_3, \alpha_r y + \beta_4) \\
  %
\begin{pmatrix}\mathfrak{A}\\\mathfrak{G}\end{pmatrix} & =
\begin{pmatrix}\alpha_l\\\alpha_r r_6\end{pmatrix} \cdot D_l(\widetilde{x}) +
\begin{pmatrix}-r_1\\-r_7\end{pmatrix} &
  %
\begin{pmatrix}\mathfrak{B}\\\mathfrak{H}\end{pmatrix} & =
\begin{pmatrix}1\\r_5\end{pmatrix} \cdot D_l(\widetilde{y}) +
\begin{pmatrix}-r_2\\r_8\end{pmatrix}\\
  %
\begin{pmatrix}\mathfrak{E}\\\mathfrak{C}\end{pmatrix} & =
\begin{pmatrix}\alpha_r\\\alpha_l r_2\end{pmatrix} \cdot D_r(\widetilde{x}) +
\begin{pmatrix}-r_5\\r_3\end{pmatrix} &
  %
\begin{pmatrix}\mathfrak{F}\\\mathfrak{D}\end{pmatrix} & =
\begin{pmatrix}1\\r_1\end{pmatrix} \cdot D_r(\widetilde{y}) +
\begin{pmatrix}-r_6\\r_4\end{pmatrix}\\
  %
  \beta_5 & = r1r_2 + r_3 + r_4 \\
  %
  \beta_6 & = r_5r_6 + r_7 + r_8 \\
  %
  \widetilde{z} & = (\mathfrak{A} \cdot \mathfrak{B}+\mathfrak{C}+\mathfrak{D}
                    ,\mathfrak{E} \cdot \mathfrak{F}+\mathfrak{G}+\mathfrak{H})
                    \\
  %
                    & = E(D(\widetilde{x}) \cdot d(\widetilde{y})) \\
                    & = (\alpha_l xy + \beta_5, \alpha_r xy + \beta_6) \\
\end{align*}

Again, all terms can be evaluated using OAFEs and the construction is composable
by commissioning David to store the resulting DRAV $\widetilde{z}$. This
construction also assures that the MAC is verified by rendering all illicit
changes to DRAVs that David can do to uniform, uncorrelated randomness. The
following equations map Davids cheating possibilities to the $\Delta$s.

\begin{align*}
  \widetilde{z} & =
  \begin{pmatrix}
    (\alpha_l D_l(\widetilde{x})-r_1)
    (         D_l(\widetilde{y})-r_2) \\
    (\alpha_r D_r(\widetilde{x})-r_5)
    (         D_r(\widetilde{y})-r_6)
  \end{pmatrix}
  +
  \begin{pmatrix}
    \alpha_lr_2 D_r(\widetilde{x}) + r_3 +
    r_1         D_r(\widetilde{y}) + r_4 \\
    \alpha_rr_6 D_l(\widetilde{x}) + r_7 +
    r_5         D_l(\widetilde{y}) + r_8
  \end{pmatrix} \\
%
  & =
  \begin{pmatrix}
    \alpha_l     D_l(\widetilde{x}) D_l(\widetilde{y})
    -\alpha_lr_2 D_l(\widetilde{x})
    -r_1         D_l(\widetilde{y})
    +r_1r_2 \\
    \alpha_r     D_r(\widetilde{x}) D_r(\widetilde{y})
    -\alpha_rr_6 D_r(\widetilde{x})
    -r_5         D_r(\widetilde{y})
    +r_5r_6
  \end{pmatrix} \\
  &\ \ \ +
  \begin{pmatrix}
    \alpha_lr_2 D_r(\widetilde{x}) + r_3 +
    r_1         D_r(\widetilde{y}) + r_4 \\
    \alpha_rr_6 D_l(\widetilde{x}) + r_7 +
    r_5         D_l(\widetilde{y}) + r_8
  \end{pmatrix} \\
%
  & =
  \begin{pmatrix}
    \alpha_l     \left(x + \frac{\Delta_1}{\alpha_l}\right)
                 \left(y + \frac{\Delta_3}{\alpha_l}\right)
    -\alpha_lr_2 \left(x + \frac{\Delta_1}{\alpha_l}\right)
    -r_1         \left(y + \frac{\Delta_3}{\alpha_l}\right)
    +r_1r_2 \\
    \alpha_r     \left(x + \frac{\Delta_2}{\alpha_r}\right)
                 \left(y + \frac{\Delta_4}{\alpha_r}\right)
    -\alpha_rr_6 \left(x + \frac{\Delta_2}{\alpha_r}\right)
    -r_5         \left(y + \frac{\Delta_4}{\alpha_r}\right)
    + r_5r_6
  \end{pmatrix} \\
  &\ \ \ +
  \begin{pmatrix}
    \alpha_lr_2  \left(x + \frac{\Delta_2}{\alpha_r}\right) + r_3 +
    r_1          \left(y + \frac{\Delta_4}{\alpha_r}\right) + r_4 \\
    \alpha_rr_6  \left(x + \frac{\Delta_1}{\alpha_l}\right) + r_7 +
    r_5          \left(y + \frac{\Delta_3}{\alpha_l}\right) + r_8
  \end{pmatrix} \\
%
  & =
  \begin{pmatrix}
    \alpha_l(xy) + (r_1r_2 + r_3 + r_4)
    + \Delta_3x + \Delta_1y
    + \frac{\Delta_1\Delta_3}{\alpha_l}
    - \Delta_1r_2
    + \frac{\Delta_2\alpha_lr_2}{\alpha_r}
    - \frac{\Delta_3r_1}{\alpha_l}
    + \frac{\Delta_4r_1}{\alpha_r}
    \\
    \alpha_r(xy) + (r_5r_6 + r_7 + r_8)
    + \Delta_4x + \Delta_2y
    + \frac{\Delta_2\Delta_4}{\alpha_r}
    + \frac{\Delta_1\alpha_lr_6}{\alpha_l}
    - \Delta_2r_6
    + \frac{\Delta_3r_5}{\alpha_l}
    - \frac{\Delta_4r_5}{\alpha_r}
  \end{pmatrix} \\
%
\end{align*}

\noindent{}That leads to two possibilities that will be discussed in detail:
Either $E$'s inputs are both well--formed or not.  Although the DRAVs
$\widetilde{x}$ and $\widetilde{y}$ are both used in multiple affine expression,
it is safe to assume they have the same value. At the first glance, one could
think a malicious adversary could use different values for the same variable.
But since all expressions depending on the same variable are evaluated using one
and the same OAFE, the attacker has to commit itself to one value for one
variable (see chapters \ref{def:OAFE} and \ref{def:OPE}).

Possibility 1: The DRAVs $\widetilde{x}$ and $\widetilde{y}$ are well--formed.
This leads to a DRAV encoding the desired result $E(x \cdot y)$. The resulting
encryption keys for $\widetilde{z}$ are $\alpha_l$, $\alpha_r$ (static keys) and
$\beta = r_1r_2 + r_3 + r_4$, $\beta' = r_5r_6 + r_7 + r_8$ (dynamic keys).

\begin{align*}
  %
  \Delta_1=\Delta_2=\Delta_3=\Delta_4=0 \Rightarrow
  \widetilde{z} =
  \begin{pmatrix}
    \alpha_l(xy) + (r_1r_2 + r_3 + r_4) \\
    \alpha_r(xy) + (r_5r_6 + r_7 + r_8)
  \end{pmatrix} \\
\end{align*}

\noindent{}The decrypted value is $z = D(\widetilde{z}) = xy$ as expected.


Possibility 2: At least one of the DRAVs $\widetilde{x}$ and $\widetilde{y}$ is
non--well--formed. If at least one DRAV is non--well--formed, at least one
$\Delta$ is non--zero. This leads to a non--well--formed DRAV $\widetilde{e}$
whose both components are uniformly at random.

\begin{align*}
  &
  \Delta_1 \neq 0 \vee \Delta_2 \neq 0 \vee
  \Delta_3 \neq 0 \vee \Delta_4 \neq 0
  \Rightarrow \\
  %
  &
  \widetilde{z} =
  \begin{pmatrix}
    \alpha_l(xy) + (r_1r_2 + r_3 + r_4)
    + \Delta_3x + \Delta_1y
    + \frac{\Delta_1\Delta_3}{\alpha_l}
    - \Delta_1r_2
    + \frac{\Delta_2\alpha_lr_2}{\alpha_r}
    - \frac{\Delta_3r_1}{\alpha_l}
    + \frac{\Delta_4r_1}{\alpha_r}
    \\
    \alpha_r(xy) + (r_5r_6 + r_7 + r_8)
    + \Delta_4x + \Delta_2y
    + \frac{\Delta_2\Delta_4}{\alpha_l}
    + \frac{\Delta_1\alpha_lr_6}{\alpha_r}
    - \Delta_2r_6
    + \frac{\Delta_3r_5}{\alpha_r}
    - \frac{\Delta_4r_5}{\alpha_l}
  \end{pmatrix} \\
\end{align*}

\noindent{}As one can easily see, if at least one $\Delta \neq 0$ the decoded
result ($z = D(\widetilde{z})$) will comprise at least one term that depends on
fresh, uniform randomness ($r_{1 \ldots 8}$). In a finite field this means that
both components are uniformly at random. Additionally the problem with
multiplications that evaluate to $0$ is fixed in this version.

However, this process still has one potential flaw: The resulting term is
potentially not uncorrelated to the OAFE outputs ($\mathfrak{A}$ to
$\mathfrak{H}$) even when the attacker forged a DRAV. Assuming, David forged at
least $\widetilde{x_l}$. This means $\Delta_1 \neq 0$ and from $\mathfrak{A}$
an attacker can learn:

\begin{align*}
  %
  \mathfrak{A} = \alpha_l (x+\frac{\Delta_1}{\alpha_l}) - r_1
  \Leftrightarrow r_1 = \alpha_l x + \Delta_1 - \mathfrak{A} &
  %
\end{align*}

Because an attacker knows $\Delta_1$,  $\mathfrak{A}$ (OAFE output) and the
environment may know $x$, there is a correlation between the random number $r_1$
and the error term that should be uncorrelated to any thing else. Similar
arguments hold for the other secret random numbers $r_{2 \ldots 8}$. Therefore,
the secure multiplication construction used for this thesis is another further
development. Chapter \ref{sec:sec-muls} explains the final construction in
depth.


% SECURE MULTIPLICATION CONSTRUCTION
\JWlfour{Secure Multiplication Construction}
\label{sec:sec-muls}

The security flaw of the last vulnerable multiplication construction (see
last construction in chapter \ref{sec:enc-muls}) is a potential correlation
between OAFE outputs and the errors terms when David forges DRAVs. This final
multiplication construction therefore adds uncorrelated random values to every
OAFE output when the input was forged. The general idea is to split the OAFE
output in two parts called \emph{radicals}. The sum of the two radicals that
belong together has the same value as the OAFE outputs in the last vulnerable
construction. Obviously the value is only the same iff David did not try to
forge the DRAVs.

\paragraph{The \emph{radicals} trick} is to modify OAFE calculations such as
$\Phi \cdot D_\delta(\widetilde{v}) + \Psi$, $\delta \in \{l, r\}$ being the
tuple component (left/right), $\widetilde{v}$ a DRAV, and $\Phi, \Psi \in
\mathbb{K}$ the
OAFE parameters. The calculations get changed to two calculations ($!\delta$
being two other tuple component, $!\delta = l \Leftrightarrow \delta = r \wedge
!\delta = r \Leftrightarrow \delta = l$) $R_1$ and $R_2$ in the equations below.
The values $\kappa$ and $\gamma$ are fresh values uniformly at random, that are
only used to protect one OAFE calculation $\Phi \cdot D_\delta(\widetilde{v}) +
\Psi$.

\begin{align*}
  %
  R_1 & = (\kappa -1)\cdot(\Phi \cdot D_\delta(\widetilde{v})+\Psi) + \gamma \\
  R_2 & = (\kappa)\cdot(\Phi \cdot D_{!\delta}(\widetilde{v})+\Psi) - \gamma \\
  %
\end{align*}

The benefit of $R_1$ and $R_2$ is their sum: $R_1 + R_2 = \Phi \cdot
D_\delta(\widetilde{v}) + \Psi$ if and only if $D_\delta(\widetilde{v}) =
D_{!\delta}(\widetilde{v})$. And this condition is the condition whether
$\widetilde{v}$ is well--formed or not (see chapter \ref{sec:well-formed-DRAV}).
If $\widetilde{v}$ is non--well--formed , $R_1 + R_2$ will contain terms
depending on $\kappa$.

\paragraph{The combination of the radicals trick and the former version} is
given in the equations below ($\odot$ denotes component--wise multiplication).
The is the last iteration in the development of secure multiplication for this
thesis.

\begin{align*}
  %
  \widetilde{x} & = E(x) = (\alpha_l x + \beta_1, \alpha_r x + \beta_2) \\
  %
  \widetilde{y} & = E(x) = (\alpha_l y + \beta_3, \alpha_r y + \beta_4) \\
  %
\begin{pmatrix}
  \mathfrak{A}_1\\\mathfrak{G}_1\\\mathfrak{E}_2\\\mathfrak{C}_2
\end{pmatrix} & =
\begin{pmatrix}1-\kappa_1\\1-\kappa_2\\\kappa_5\\\kappa_6\end{pmatrix} \odot
  \left(
  \begin{pmatrix}\alpha_l\\\alpha_r r_6\\\alpha_r\\\alpha_l r_2\end{pmatrix}
    \cdot D_l(\widetilde{x}) +
  \begin{pmatrix}-r_1\\-r_7\\-r_5\\r_3\end{pmatrix}
  \right) +
\begin{pmatrix}\gamma_1\\\gamma_2\\-\gamma_5\\-\gamma_6\end{pmatrix}\\
  %
\begin{pmatrix}
  \mathfrak{B}_1\\\mathfrak{H}_1\\\mathfrak{F}_2\\\mathfrak{D}_2
\end{pmatrix} & =
\begin{pmatrix}1-\kappa_3\\1-\kappa_4\\\kappa_7\\\kappa_8\end{pmatrix} \odot
  \left(
  \begin{pmatrix}1\\r_5\\1\\r_1\end{pmatrix}
    \cdot D_l(\widetilde{y}) +
  \begin{pmatrix}-r_2\\r_8\\-r_6\\r_4\end{pmatrix}
  \right) +
\begin{pmatrix}\gamma_3\\\gamma_4\\-\gamma_7\\-\gamma_8\end{pmatrix}\\
  %
\begin{pmatrix}
  \mathfrak{E}_1\\\mathfrak{C}_1\\\mathfrak{A}_2\\\mathfrak{G}_2
\end{pmatrix} & =
\begin{pmatrix}1-\kappa_5\\1-\kappa_6\\\kappa_1\\\kappa_2\end{pmatrix} \odot
  \left(
  \begin{pmatrix}\alpha_r\\\alpha_l r_2\\\alpha_l\\\alpha_r r_6\end{pmatrix}
    \cdot D_r(\widetilde{x}) +
  \begin{pmatrix}-r_5\\r_3\\-r_1\\-r_7\end{pmatrix}
  \right) +
\begin{pmatrix}\gamma_5\\\gamma_6\\-\gamma_1\\-\gamma_2\end{pmatrix}\\
  %
\begin{pmatrix}
  \mathfrak{F}_1\\\mathfrak{D}_1\\\mathfrak{B}_2\\\mathfrak{H}_2
\end{pmatrix} & =
\begin{pmatrix}1-\kappa_7\\1-\kappa_8\\\kappa_3\\\kappa_4\end{pmatrix} \odot
  \left(
  \begin{pmatrix}1\\r_1\\1\\r_5\end{pmatrix}
    \cdot D_r(\widetilde{y}) +
  \begin{pmatrix}-r_6\\r_4\\-r_2\\r_8\end{pmatrix}
  \right) +
\begin{pmatrix}\gamma_7\\\gamma_8\\-\gamma_3\\-\gamma_4\end{pmatrix}\\
  %
  \beta_5 & = r1r_2 + r_3 + r_4 \\
  %
  \beta_6 & = r_5r_6 + r_7 + r_8 \\
  %
  \widetilde{z} & =
  \begin{pmatrix}%
    %
    (\mathfrak{A}_1+\mathfrak{A}_2) \cdot
    (\mathfrak{B}_1+\mathfrak{B}_2) +
    (\mathfrak{C}_1+\mathfrak{C}_2) +
    (\mathfrak{D}_1+\mathfrak{D}_2)\\
    %
    (\mathfrak{E}_1+\mathfrak{E}_2) \cdot
    (\mathfrak{F}_1+\mathfrak{F}_2) +
    (\mathfrak{G}_1+\mathfrak{G}_2) +
    (\mathfrak{H}_1+\mathfrak{H}_2)
    %
  \end{pmatrix} \\
  %
  & = E(D(\widetilde{x}) \cdot d(\widetilde{y})) \\
  & = (\alpha_l xy + \beta_5, \alpha_r xy + \beta_6) \\
\end{align*}

The following equations analyze the term ($\mathfrak{A}_1 + \mathfrak{A}_2$)
when David is not honest and either the left side ($\Rightarrow \Delta_1 \neq
0$) or the right side ($\Rightarrow \Delta_2 \neq 0$) of the tuple
$\widetilde{x}$ is forged.

\begin{align*}
%
  \mathfrak{A}_1 &=
  (1 - \kappa_1) \cdot
  (\alpha_l \cdot D_l(\widetilde{x}) - r_1) +
  \gamma_1 \\
  & =
  (1 - \kappa_1) \cdot
  \left(\alpha_l \cdot \left(x + \frac{\Delta_1}{\alpha_l}\right) - r_1\right) +
  \gamma_1 \\
  & =
  (1 - \kappa_1) \cdot
  \left(\alpha_l x + \Delta_1 - r_1\right) +
  \gamma_1 \\
  & =
  (1 - \kappa_1) \cdot
  \left(\alpha_l x - r_1\right) +
  \gamma_1 +
  (\Delta_1 - \kappa_1\Delta_1)\\
  %
  \mathfrak{A}_2 &=
  \kappa_1 \cdot
  (\alpha_l \cdot D_l(\widetilde{x}) - r_1) +
  -\gamma_1 \\
  & =
  \kappa_1 \cdot
  \left(\alpha_l \cdot \left(x + \frac{\Delta_2}{\alpha_r}\right) - r_1\right) +
  -\gamma_1 \\
  & =
  \kappa_1 \cdot
  \left(\alpha_l x + \frac{\alpha_l\Delta_2}{\alpha_r} - r_1\right) +
  -\gamma_1 \\
  & =
  \kappa_1 \cdot
  \left(\alpha_l x - r_1\right) +
  -\gamma_1 +
  \left(\frac{\kappa_1\alpha_1\Delta_2}{\alpha_r}\right)\\
  %
\mathfrak{A}_1 + \mathfrak{A}_2 &=
  \alpha_l x - r_1 +
  \left(
    \Delta_1 - \kappa_1\Delta_1 +
    \frac{\kappa_1\alpha_1}{\alpha_r}\Delta_2
  \right)\\
  &=
  \alpha_l x - r_1 +
  \left(
    \kappa_1 \cdot \left(\frac{\Delta_1}{\kappa_1} - \Delta_1 +
    \frac{\alpha_l}{\alpha_r}\Delta_2\right)
  \right)\\
%
\end{align*}

Because an attacker cannot know $\alpha_l$, $\alpha_r$, or $\kappa_1$, the error
term will (except for the negligible probability) contain $\kappa_1$. Obviously,
if $\Delta_1 = \Delta_2 = 0$ the attacker was honest and no error term gets
generated. Because $\kappa_1$ is uncorrelated to any other term in the whole
process, the DRAV will be made of uniform randomness, if an attacker tires to
cheat. This is the DRAE executing the multiplication of the DRAVs
$\widetilde{x}$ and $\widetilde{y}$ in the formal notation (see chapter
\ref{sec:DRAE-formal}).

\begin{align*}
  %
  E & = \widetilde{x} \cdot \widetilde{y} \\
  %
  E & =
  \Bigg(\left\{\left(
      \begin{pmatrix}
        (\mathfrak{A}_1, \mathfrak{A}_2) \\
        (\mathfrak{E}_1, \mathfrak{E}_2)
      \end{pmatrix},
      \begin{pmatrix}
        (\mathfrak{B}_1, \mathfrak{B}_2) \\
        (\mathfrak{F}_1, \mathfrak{F}_2)
      \end{pmatrix}
  \right)\right\},
  \bigg\{
    \begin{pmatrix}
      \mathfrak{C}_1 \\
      \mathfrak{G}_1
    \end{pmatrix},
    \begin{pmatrix}
      \mathfrak{C}_2 \\
      \mathfrak{G}_2
    \end{pmatrix},
    \begin{pmatrix}
      \mathfrak{D}_1 \\
      \mathfrak{H}_1
    \end{pmatrix},
    \begin{pmatrix}
      \mathfrak{D}_2 \\
      \mathfrak{H}_2
    \end{pmatrix}
  \bigg\}
  , (0, 0)
  \Bigg)
  %
\end{align*}


% FORMAL DESCRIPTION
\JWlthree{Formal Description}
\label{sec:DRAE-formal}

\JWtodo{An radical encryption anpassen}

Because DRAEs are tightly related to DRAVs, they fulfill similar properties:

\begin{enumerate}

  \item \label{prop:drae-encrypted} DRAEs are encrypted: Without the encryption
    keys, they do not reveal any information.

  \item \label{prop:drae-signed} DRAEs are signed: If someone tries to forge a
    DRAE, it will become non--well--formed and operations with that DRAE result
    in non--well--formed DRAVs.

  \item DRAEs are not exchangeable with other DRAEs because every DRAE is
    encrypted with fresh keys.

  \item \label{prop:drae-oafe} DRAEs can be securely evaluated using OAFEs.

\end{enumerate}

\JWtodo{Hier Radicals einbauen}

\noindent{}Informally, a DRAE is composed of two finite multi--sets and a
constant DRAV\@. The first multi--set, called the \emph{multiplicative terms}
contains tuples of computations. The second multi--set, called the
\emph{additive terms} contains computations that evaluate to DRAVs. The constant
DRAV represents the constant terms in the arithmetic expression. The
component--wise multiplication of each of the computation tuples (from the
multiplicative terms) yields DRAVs, too. The sum of the constant DRAV, the DRAVs
obtained from the additive terms and the DRAVs obtained from the multiplicative
terms is the evaluated value of this DRAE\@. Again the evaluated value is a
valid DRAV\@.

More formally, a DRAE can be described as follows where
$\mathcal{E}_\mathcal{C}$ represents the DRAEs, $\mathcal{C}$ the affine
computations, $\mathcal{V}$ the set of all DRAVs and $\mathcal{V}_\mathcal{C}$
the computations that lead to DRAVs.

\begin{align}
%
  &\text{The static keys } \alpha_l, \alpha_r \in \mathbb{K} \setminus \{0\},
  \alpha_l +
  \alpha_r \neq 0\nonumber\\
%
  &\text{The dynamic keys } \beta, \beta' \in \mathbb{K} \nonumber\\
%
  &s, x, x', i \in \mathbb{K} \nonumber\\
%
  \mathcal{C} = & \{ c(x) = s \cdot x + i \} \nonumber\\
%
  \mathcal{V}_\mathcal{C} = & \{ (\alpha_l \cdot f(x) + \beta,
                      \alpha_r \cdot f'(x') + \beta' )
                    \mid f, f' \in \mathcal{C} \} \nonumber\\
%
\label{rel:DRAE}
\mathcal{E}_\mathcal{C} = & \{ (M, A, k) \mid
M \subseteq (\mathcal{V}_\mathcal{C}, \mathcal{V}_\mathcal{C}) \times
(\mathcal{V}_\mathcal{C}, \mathcal{V}_\mathcal{C});
A \subseteq \mathcal{V}_\mathcal{C};
k \in \mathcal{V};
      A, M~\text{finite multi--sets} \}
%
\end{align}

As stated in the introduction to this chapter, the calculations are hidden
inside OAFEs. When the party that built the DRAE transmits it to the evaluating
party, it obviously replaces the concrete affine computations by references to
the OAFEs that calculate them obliviously.  Because of the definition of OAFEs
(see chapter \ref{def:OAFE}) the evaluating party will only learn exactly one
evaluation $c(x)$ for each variable $x$. A \emph{pre--evaluated DRAE} is the
entity that the evaluating party obtains after successfully having evaluated all
the computations (using the OAFEs). The pre--evaluated DRAEs ($\mathcal{E}$) are
defined as follows:

\begin{align}
  \mathcal{V} = & \{ (v_l, v_r) \mid v_l, v_r \in \mathbb{K} \}
  &\text{, the DRAVs (chapter \ref{def:DRAV})} \nonumber\\
%
  \label{rel:pre-eval-DRAE}
  \mathcal{E} = & \{ (M, A, k) \mid
      M \subseteq \mathcal{V} \times \mathcal{V};
      A \subseteq \mathcal{V};
      k \in \mathcal{V} \}
      &\text{, the pre--evaluated DRAEs}
\end{align}


% DECODING DRAEs
\JWlthree{Decoding DRAEs}
\label{sec:DRAE-decoding}

\JWtodo{An Radical Encryption anpassen}

\JWtodo{Noch natürlich sprachlich hinschreiben was geht}
Entirely evaluating a pre--evaluated DRAE to obtain the DRAV is straightforward:
A pre--evaluated DRAE $e \in \mathcal{E} = (M,A, k)$ evaluates to its
single resulting DRAV $r \in \mathcal{V}$ as follows (all additions performed
component--wise):

\begin{align*}
M' &= \Bigg\{ m_1 \cdot m_2\ \Bigg|\ \begin{pmatrix}m_1\\m_2\end{pmatrix}
\in M \Bigg\} \\
r & = \sum_{a \in A}a + \sum_{m \in M'}m + k
\end{align*}


%
% DUAL RANDOMIZED AFFINE CIRCUITS
%
\JWltwo{Dual Randomized Affine Circuits}
\label{sec:drac}

\JWdef{Dual Randomized Affine Circuit}{DRAC}{s} are representations of entire
arbitrary arithmetic circuits. A DRAC can be envisioned as an encoding for an
entire arithmetic function. As discussed in the previous chapters, not every
arithmetic function can be expressed as one DRAE\@. Therefore, the overall
function is divided in as many DRAEs as needed. In the situation that one DRAE
alone is not enough, extra DRAEs are used that evaluate to temporary
intermediate variables. Every DRAE can use the evaluated intermediate variables
of preceding DRAEs when the computation was too complex for a single DRAE\@.
This resembles to evaluate the simple function $f(x) = (a \cdot b) + (c \cdot
d)$ as a sequence of sub--expressions, each assigned to an intermediate
variable: $t_0 \leftarrow a \cdot b; t_1 \leftarrow c \cdot d; y \leftarrow t_0
+ t_1$.  In just the same way, DRACs are sequences of DRAEs, each assigned to a
variable.  Because DRAEs evaluate to DRAVs, the variables will hold a DRAV as
soon as the DRAE was evaluated. Naturally the DRAC evaluation has to be
performed in the correct order, otherwise some variables may not have their
values assigned yet when needed.


% EVALUATION
\JWlthree{Evaluating a DRAC}
\label{sec:DRAC-eval}

A DRAC evaluates to its value by evaluating one DRAE after the other and
assigning the resulting DRAV to the variable the DRAE is assigned to. Before the
evaluation of the first DRAE, all (unencrypted) function parameters are
evaluated to DRAVs using the provided OAFEs. The DRAE sequence is ordered, so a
DRAE only needs values (DRAVs) of DRAEs evaluated before. The last DRAV can then
be decoded as explained in chapter \ref{sec:drav-final-decoding}. The result
from the decoding of the final DRAE is the result of the whole computation or
uniform at random (meaning $\bot$).


%
% OBLIVIOUS POLYNOMIAL EVALUATION
%
\JWltwo{Oblivious Polynomial Evaluation}
\label{sec:OPE}

This section describes the \JWdef{Oblivious Polynomial Evaluation}{OPE} of a
univariate polynomial $f(x) = \sum_{i=0}^k a_ix^i$. OPE is the joint evaluation
of a polynomial that is only known by the first party at a node that is only
known by the second party. The evaluation should neither reveal the polynomial
to the second party nor reveal the node to the first party.

Using technique described in this thesis, the first party (\JWpOne{}) starts the
process by choosing the polynomial coefficients and transforming  $f$ into a
DRAC (see chapter \ref{def:DRAC}. The number of DRAEs the DRAC consists of will
be in $O(n)$, $n$ being the number of arithmetic operations needed by evaluate
$f$ as usual. When using Horner's \cite{cormen01} evaluating a polynomial of
degree $n$ only requires $n$ additions and $n$ multiplications. To securely
evaluate the DRAC, the OAFE setup is calculated by the first party. The first
party has to accumulate all OAFE calls using the same variable to one OAFE call
resulting in a vector. Otherwise, a corrupted party could evaluate the OAFEs
with different values for one and the same variable $v$.

After the first party has chosen the DRAC and the OAFE configuration, it sends
them to the second party. The DRAEs inside the DRAC that get transmitted to the
second party resemble the pre--evaluated DRAEs from chapter \ref{def:DRAE}.
Naturally, every affine function inside the DRAEs is replaced by a OAFE
reference (and the position in the resulting vector) that has to be used to
calculate the value. Otherwise the encryption keys would be revealed to the
second party.

The OAFEs are sent to the second party (\JWpTwo{}) using the David \& Goliath
protocol \cite{davidgoliath}. The DRAC is transmitted using a singed and
encrypted channel. The identity of the party the DRAC is transferred to does not
need to be verified because a DRAC does not contain any secrets. A DRAC is made
of DRAEs that only refer to uncorrelated uniform randomness and OAFEs.

After having received the DRAC and the OAFE references, the second party can
evaluate the DRAC\@. It evaluates the DRAEs one by one and assigns the resulting
DRAV to the variable as described in the DRAC\@. As explained in chapters
\ref{sec:drav-final-decoding} and \ref{sec:DRAC-eval} both components of the
final DRAV have then to be added and passed to the final OAFE which yields the
unencrypted evaluated value of the polynomial.


% VERIFYING THE POLYNOMIAL DEGREE
\JWltwo{Verifying the Polynomial Degree}
\label{sec:max-poly-degree}

From a given DRAE it is easily possible to calculate the maximal polynomial
degree of the function the DRAE encodes. Since multiplications of DRAEs are
performed by the party that evaluates the DRAEs, it is able to keep book of the
maximal degree of the overall function. The following steps describe the process
of calculating the maximal degree the function the DRAE encodes.

\begin{itemize}

  \item Constant terms are annotated with maximal degree $0$.

  \item Terms that refer to the function parameters are annotated with maximal
    degree $1$.

  \item Terms that refer to other DRAEs evaluated before are annotated with the
    maximal degree of the DRAE they refer to.

  \item The multiplicative DRAE terms are annotated with the sum of both terms
    they multiply.

  \item The additive DRAE terms are annotated with the maximal degree of the
    DRAE they refer to.

  \item The last step is to annotate the DRAE itself with the maximal annotation
    of all its descendants.

\end{itemize}

Since there is always a final DRAE that yields the function's result in every
DRAC, the annotated maximal degree of this DRAE is the maximal degree the
function the DRAC encodes can be of. Before evaluating a DRAC, \JWpTwo{} has to
verify the degree of the polynomial it is supposed to evaluate equals the
parametrized degree.

% vim: set spell spelllang=en_us fileencoding=utf8 formatoptions=tcroql : %
