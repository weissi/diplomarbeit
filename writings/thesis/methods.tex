\JWlone{Methods}
\label{sec:methods}

This chapter describes how arbitrary arithmetic functions can be expressed in
terms of affine expressions. This is the most important part of this thesis
because it is the key part of evaluating arbitrary arithmetic expressions
using OAFEs \cite{davidgoliath}.


%
% DEFINITIONS
%
\JWltwo{Definitions}
\label{sec:rae-definitions}

This chapter defines important entities that are used to define the more complex
entities in the following chapters.

% Field K
\JWlthree*{Field $K$}

\label{def:field} Throughout this thesis, $K$ represents an arbitrary large
finite field, such as $\mathbb{F}_{2^{256}}$.


%
% DUAL RANDOMIZED AFFINE VALUES
%
\JWltwo{Dual Randomized Affine Values}
\label{sec:drav}

\JWdef{Dual Randomized Affine Value}{DRAV}{s} are encrypted, signed values
representing a scalar value of the field $K$. Each DRAV is encrypted by a pair
of \emph{dual keys}. The first dual key, the \emph{static key}, remains the same
in the whole DRAC (see chapter \ref{def:DRAC}) generation procedure and is
usually written as $(\alpha_l, \alpha_r)$. The second dual key, the
\emph{dynamic key} is a short--lived key, usually represented as $(\beta,
\beta')$. Two DRAVs only share the same dynamic key by hazard but always share
the same static key. Encoding a regular value $v \in K$ as a DRAV
$\widetilde{v} \in \mathcal{V}_K$ is straightforward, most of the time the
universal encoding function $E(v)$ is used to describe DRAV encoding.

\begin{align*}
  \widetilde{v} = E(v) = (\widetilde{v_l}, \widetilde{v_r}) =
    (\alpha_l \cdot v + \beta, \alpha_r \cdot v + \beta')
\end{align*}

\noindent{}So, if the keys are uniformly at random, the two components of the
tuple $\widetilde{v}$ are uniformly at random, too. Decoding is (most of the
time using the universal decoding function $D(\widetilde{v})$):

\begin{align*}
  v = D(\widetilde{v}) =
  \left\{
    \begin{array}{l l}
      \frac{\widetilde{v_l} - \beta}{\alpha_l} & \quad
      \text{if}~\frac{\widetilde{v_l} - \beta}{\alpha_l} =
      \frac{\widetilde{v_r} - \beta'}{\alpha_r}\\
      \bot & \quad \text{otherwise ($\widetilde{v}$ is non--well--formed)}\\
    \end{array}\right.
\end{align*}


% WELL-FORMED DRAVs
\JWlthree{Well--Formed DRAVs}

A DRAV $\widetilde{v}$ is well--formed iff $D(\widetilde{v}) \neq \bot$.
Therefore, if $D(\widetilde{\chi}) = \bot$, $\chi$ is non--well-formed.


% DIRECT DRAV ARITHMETIC
\JWlthree{Direct DRAV Arithmetic}
\label{sec:direct-DRAV-arithmetic}

Direct DRAV arithmetic only supports addition ($+$) of two DRAVs. Indirect DRAV
arithmetic has to be used for other operations. The advantage of direct DRAV
arithmetic is that it can be performed without the knowledge of a DRAV's
encryption keys.

\paragraph{Addition of Well--Formed DRAVs:} Two DRAVs $\widetilde{x} =
(\widetilde{x_l}, \widetilde{x_r})$ and $\widetilde{y} = (\widetilde{y_l},
\widetilde{y_r})$ can be added componentwise to $\widetilde{z} =
\left(\widetilde{x_1} + \widetilde{y_1}, \widetilde{x_2} +
\widetilde{y_2}\right)$. The encryption keys for $\widetilde{z}$ will be
$(\alpha_l, \alpha_r)$ and $(\beta_1 + \beta_3, \beta_2 + \beta_4)$ assuming
$\widetilde{x}$ was encrypted with $(\alpha_l, \alpha_r)$ and $(\beta_1,
\beta_2)$ and $y$ was encrypted with $(\alpha_l, \alpha_r)$ and $(\beta_3,
\beta_4)$.

\subparagraph{Proof:} From ($\widetilde{x} = \left(\alpha_l \cdot x + \beta_1,
\alpha_r \cdot x + \beta_2\right)$, $\widetilde{y} = \left(\alpha_l \cdot x +
\beta_3, \alpha_r \cdot x + \beta_4\right)$) it's obvious that: $\widetilde{z} =
\left(\alpha_l \cdot (x+y) + (\beta_1 + \beta_3), \alpha_r \cdot (x+y) +
(\beta_2 + \beta_4)\right)$ and $\widetilde{z}$ is well--formed.

\paragraph{Addition of Non--Well--Formed DRAVs:} It's of particular interest the
following property holds: $\forall \widetilde{x}: \widetilde{x} + \bot = \bot
+ \widetilde{x} = \bot$. Let $\widetilde{\chi}$ be a non--well--formed DRAV,
so: $\widetilde{\chi} = (\alpha_l \cdot \chi + \beta_3 + \Delta_l, \alpha_r
\cdot \chi + \beta_4 + \Delta_r)$. The component--wise addition
$\widetilde{\nu}$ of $\widetilde{\chi}$ to any well--formed $\widetilde{x} =
(\alpha_l \cdot x + \beta_1, \alpha_r \cdot x + \beta_2)$ is $\widetilde{\nu} =
(\alpha_l \cdot (x+\chi) + (\beta_1+\beta_3) + \Delta_l, \alpha_r \cdot (x+\chi)
+ (\beta_2+\beta_4) + \Delta_r)$. Using the universal decoding function $D$, the
value of $\chi$ is $\chi = D(\widetilde{\chi}) = (x + \chi +
\frac{\Delta_l}{\alpha_l}, x + \chi + \frac{\Delta_r}{\alpha_r})$. So: $\forall
(\Delta_r, \Delta_l) \in K \setminus \{(0, 0)\} \wedge \frac{\Delta_l}{\alpha_l}
\neq \frac{\Delta_r}{\alpha_r}: D(\widetilde{\chi}) = \bot$. Since the
encryption keys are not known to an attacker, $\frac{\Delta_l}{\alpha_l} \neq 0
\wedge \frac{\Delta_r}{\alpha_r}$ hold except for a negligible probability if
$\Delta_r \neq 0 \vee \Delta_r \neq 0$ and that's the property for being forged
(non--well--formed) which was the assumption. Trivially $\bot + \bot = \bot$ by
a similar argument.


% INDIRECT DRAV ARITHMETIC
\JWlthree{Indirect DRAV Arithmetic}
\label{sec:indirect-DRAV-arithmetic}

Indirect DRAV arithmetic assumes the universal encoding and decoding functions
$E(v)$ and $D(\widetilde{v})$ and therefore the knowledge of the encryption
keys. Another possibility is to map indirect DRAV arithmetic to OAFE calls that
are set up by a party that knows the encryption keys.

Indirect DRAV arithmetic is straightforward but can only be performed by a party
in possession of the encryption keys. For any operator $\odot$, $\widetilde{a}
\odot \widetilde{b} = E(D(\widetilde{a}) \odot D(\widetilde{b}))$. Obviously
it's important that $\forall x: \bot \odot x = x \odot \bot = \bot$. $\bot$ can
be represented as a DRAV as a tuple that is made up of two values uniform at
random.


% FINAL DRAV DECODING
\JWlthree{Final DRAV Decoding}
\label{sec:drav-final-decoding}

Finally decoding a DRAV can be trivially done using the universal decoding
function $D(\widetilde{v})$. But $D$ is only available to a party that is in
possession of the encryption keys.

Additionally a DRAV can also be finally decoded only one additional OAFE call.
The following procedure will decode a DRAV to a final scalar value although
$D$ is a partial function. To enable a second party---that is not in possession
of the encryption keys---to decode a DRAV $\widetilde{v} = (\widetilde{v_1},
\widetilde{v_2})$, the first party---in possession of the keys---needs to set up
a special OAFE, called the \emph{final OAFE} below.

The second party's input to the final OAFE is $\widehat{v} = \widetilde{v_1} +
\widetilde{v_2}$, the addition of both components of the DRAV to decode.  The
final OAFE was set up by the first party as follows: Assuming $\widetilde{v}$ is
encrypted by $(\alpha_l, \alpha_r)$ and $(\beta_1, \beta_2)$ the first party
knows $\widehat{v}$ has to be encrypted using $(\alpha_l + \alpha_r)$ and
$(\beta_1 + \beta_2)$.  Given this knowledge the final OAFE setup is
$\frac{1}{\alpha_l + \alpha_r} \cdot \widehat{v} - \frac{\beta_1 +
\beta_2}{\alpha_l + \alpha_r}$.

Again, it's important that an attacker is getting caught when trying to forge a
DRAV ($D(\widetilde{v}) = \bot$ if $\widetilde{v}$ has been forged, $\bot$ is
mapped to uniform randomness in this process since an OAFE has no
$\bot$--value). If the attacker cheated somewhere in the process and forged one
of the DRAV tuples $\widetilde{x} = (\widetilde{x_1}, \widetilde{x_2})$ to
$\widetilde{x'} = (\widetilde{x_1} + \Delta_1, \widetilde{x_2} + \Delta_2)$, the
DRAV $\widetilde{x'}$ becomes---except for a negligible
probability---non--well--formed (see section \ref{sec:drav}). The result is that
the decoded result will become uniform randomness (assuming $\widetilde{x}$ is
forged to $\widetilde{x'_1} = \widetilde{x_1} + \Delta_1$ and $\widetilde{x'_2}
= \widetilde{x_2} + \Delta_2$):

\begin{align*}
  \widehat{x'} = & \widetilde{x'_1} + \widetilde{x'_2} = \widetilde{x_1} +
  \Delta_1 + \widetilde{x_2} + \Delta_2 \\
  %
  \Rightarrow x' = & \frac{1}{\alpha_l + \alpha_v} \cdot \widehat{x'} -
  \frac{\beta_{x_1} +
  \beta_{x_2}}{\alpha_l + \alpha_v} \\
  %
  \Leftrightarrow x' = & \frac{\widetilde{x_1} + \Delta_1 +
  \widetilde{x_2} + \Delta_2}{\alpha_l + \alpha_v} -
  \frac{\beta_{x_1} +\beta_{x_2}}{\alpha_l + \alpha_v}\\
  %
  \Leftrightarrow x' = & \frac{(\alpha_l x + \beta_{x_1}) + \Delta_1 +
  (\alpha_v x + \beta_{x_2}) + \Delta_2}{\alpha_v + \alpha_l} -
  \frac{\beta_{x_1} +\beta_{x_2}}{\alpha_l + \alpha_v} \\
  %
  \Leftrightarrow x' = & \frac{(\alpha_l+\alpha_v)x + (\beta_{x_1}+\beta_{x_2} +
  \Delta_1+\Delta_2)}{\alpha_l+\alpha_v} -
  \frac{\beta_{x_1} +\beta_{x_2}}{\alpha_l + \alpha_v} \\
  %
  \Leftrightarrow x' = & x + \frac{\beta_{x_1}+\beta_{x_2}}{\alpha_l+\alpha_v}
  + \frac{\Delta_1 + \Delta_2}{\alpha_l + \alpha_v} -
  \frac{\beta_{x_1}+\beta_{x_2}}{\alpha_l + \alpha_v} \\
  %
  \Leftrightarrow x' = & x + \frac{\Delta_1 + \Delta_2}{\alpha_l + \alpha_v}\\
\end{align*}

Because an attacker is not in possession of the static encryption keys
$\alpha_l$ and $\alpha_r$, it cannot control the value of $\frac{\Delta_1 +
\Delta_2}{\alpha_l + \alpha_r}$. Since $\alpha_l$ and $\alpha_r$ are chosen
uniform at random, the result $x'$ becomes uniform at random, too.


%
% DUAL RANDOMIZED AFFINE ENCODING
%
\JWltwo{Dual Randomized Affine Encoding}
\label{sec:drae}

\JWdef{Dual Randomized Affine Encoding}{DRAE}{s} are affine representations of
parts of arithmetic circuits that fulfill several properties:

\begin{enumerate}

  \item \label{prop:drae-encrypted} DRAEs are encrypted: Without the encryption
    keys, they don't reveal any information.

  \item \label{prop:drae-signed} DRAEs are signed: If someone tries to forge a
    DRAE, it will become non--well--formed and operations with that DRAE result
    in non--well--formed DRAEs.

  \item \label{prop:drae-oafe} DRAEs can be securely evaluated using OAFEs.

  \item \label{prop:drae-not-enough} DRAEs can not express arbitrary arithmetic
    circuits alone.

\end{enumerate}

\noindent{}A DRAE can be eventually evaluated to a final value, that is a DRAV
(see chapter \ref{def:DRAV}). Intuitively, a DRAE is composed of two finite
multi--sets. The first multi--set, called the \emph{additive terms} contains
computations that can be evaluated to DRAVs. The second multi--set, called the
\emph{multiplicative terms} contains tuples of computations. The component--wise
multiplication of each of these tuples yields DRAVs, too. The addition of the
DRAVs obtained from the additive terms and the DRAVs obtained from the
multiplicative terms leads to a DRAV that is the evaluation of this DRAE.

More formally, a DRAE can be described as follows where $\mathcal{E}$ represents
the DRAEs, $\mathcal{C}$ the computations and $\mathcal{V}_\mathcal{C}$ the
computations that lead to DRAVs.

\begin{align}
%
  &\text{The static keys } \alpha_l, \alpha_r \in K \setminus \{0\} \nonumber\\
%
  &\text{The dynamic keys } \beta, \beta' \in K \nonumber\\
%
  &s, x, x', i \in K \nonumber\\
%
  \mathcal{C} = & \{ c(x) = s \cdot x + i \} \nonumber\\
%
  \mathcal{V}_\mathcal{C} = & \{ (\alpha_l \cdot f(x) + \beta,
                      \alpha_r \cdot f'(x') + \beta' )
                    \mid f, f' \in \mathcal{C} \} \nonumber\\
%
  \label{rel:DRAE}
  \mathcal{E}_\mathcal{C} = & \{ (M, A) \mid
      M \subseteq \mathcal{V}_\mathcal{C} \times
      \mathcal{V}_\mathcal{C}, A \subseteq, \mathcal{V}_\mathcal{C};
  A, M~\text{finite multi--sets} \}
%
\end{align}

Pre--evaluating a DRAE to DRAVs can be done by evaluating the OAFEs set up by
the party in possession of the encryption keys. Obviously none of the
computations $c \in \mathcal{C}$ becomes visible by the party not in possession
of the keys. The latter party will only learn exactly one evaluation $c(x)$ for
each variable $x$. This leads to pre--evaluated DRAEs of the form

\begin{align}
  \mathcal{V} = & \{ (v_l, v_r) \mid v_l, v_r \in K \}
  \text{, the DRAVs (chapter \ref{def:DRAV})} \nonumber\\
%
  \label{rel:pre-eval-DRAE}
  \mathcal{E} = & \{ (M, A) \mid
      M \subseteq \mathcal{V} \times \mathcal{V}, A \subseteq, \mathcal{V} \}
      \text{, the pre--evaluated DRAEs}
\end{align}

Evaluating a pre--evaluated DRAE is straightforward: A DRAE $e \in \mathcal{E} =
(M,A)$ can be evaluated to its single resulting DRAV $r \in \mathcal{V}$ as
follows (all additions performed component--wise):

\begin{align*}
M' &= \Bigg\{ m_1 \cdot m_2\ \Bigg|\ \begin{pmatrix}m_1\\m_2\end{pmatrix}
\in M \Bigg\} \\
r & = \sum_{a \in A}a + \sum_{m \in M'}m
\end{align*}


% DRAE ARITHMETIC
\JWlthree{DRAE Arithmetic}

%Direct Addition
\JWlfour{Addition}

Since two DRAVs can directly be added as explained in chapter
\ref{sec:direct-DRAV-arithmetic}, two DRAEs can be added by concatenating the
multiplicative ($M$ in relations \ref{rel:DRAE} and \ref{rel:pre-eval-DRAE}) and
additive ($A$) terms. Notably, although the encryption keys change, this
operation can be performed by any party, in possession of the encryption keys or
not. Obviously, the same argument holds for pre--evaluated DRAEs.


%Indirect Addition
\JWlfour{Indirect Addition via OAFEs}

The indirect addition of $\widetilde{z} = \widetilde{x_1} + \widetilde{x_2}$ is
$\widetilde{z} =
\left( E\left(D(\widetilde{x_1}) + D(\widetilde{y_1})\right),
       E\left(D(\widetilde{x_2}) + D(\widetilde{y_2})\right)
\right)$
(see chapter \ref{sec:indirect-DRAV-arithmetic}).
Since $E(x)$ and $D(x)$ are both linear functions, $E\left(D(\ldots)
+D(\ldots)\right)$ are linear functions, too that can be evaluated using two
OAFE calls.  Naturally the OAFEs have to be configured appropriately by the
party in possession of the encryption keys.


%Multiplication
\JWlfour{Multiplication}

As described in chapter \ref{def:DRAV}, DRAV cannot be multiplied directly.
Therefore DRAVs have to be multiplied indirectly requiring additional OAFE
calls. To maintain the important DRAV and DRAE property that any operation on
bottom ($\bot$) results in bottom, the two components of each DRAV get mixed for
multiplication.

\JWtodo{Warum müssen sie gemixt werden: Das Argument mit gegen
Null prüfen}


\begin{align*}
  e & \in \mathcal{E}; \widetilde{x}, \widetilde{y} \in \mathcal{V};
  r_1, r_2, r_3, r_4, r_5, r_6, r_7, r_8 \in K;
  \alpha_l, \alpha_r \in K \setminus \{0\} \\
  %
  e & = \widetilde{x} \cdot \widetilde{y} \\
  %
  e & = \Bigg(\Big\{\big( \alpha_l \cdot D(\widetilde{x_1}) - r_1,
                          \alpha_r \cdot D(\widetilde{x_2}) -r_5 \big) \\
    &\qquad ,     \big(   1        \cdot D(\widetilde{y_1}) - r_2,
                          1        \cdot D(\widetilde{y_2}) - r_6 \big) \Big\}\\
    &\qquad   \Big\{\big( \alpha_lr_2 \cdot D(\widetilde{x_2}) + r_3,
                          \alpha_rr_2 \cdot D(\widetilde{x_1}) + r_7 \big) \\
    &\qquad ,       \big ( r_1        \cdot D(\widetilde{y_2}) + r_4,
                           r_5        \cdot D(\widetilde{y_1}) + r_8 \big)
              \Big\}\Bigg) \\
\end{align*}

\noindent{}The resulting encryption keys of $e$ are $\alpha_l$, $\alpha_r$
(static keys) and $\beta = r_1r_2 + r_3 + r_4$, $\beta' = r_5r_6 + r_7 + r_8$
(dynamic keys).


%
% DUAL RANDOMIZED AFFINE CIRCUITS
%
\JWltwo{Dual Randomized Affine Circuits}
\label{sec:drac}

\JWdef{Dual Randomized Affine Circuit}{DRAC}{s} are representations of entire
arbitrary arithmetic circuits. DRACs are sequences of DRAEs, each assigned to a
variable.

% EVALUATION
\JWlthree{Evaluation}
\label{sec:DRAC-eval}

A DRAC can be evaluated by evaluating one DRAE after the other and assigning the
resulting DRAV to the variable the DRAE is assigned to. The DRAE sequence is
ordered, so a DRAE can be evaluated by only inputting the regular inputs
and the variables set by evaluating prior DRAEs. The last DRAV can then be
decoded as explained in chapter \ref{sec:drav-final-decoding}. The result from
the decoding of the final DRAE is the result of the whole computation or uniform
at random (meaning $\bot$).


%
% OBLIVIOUS POLYNOMIAL EVALUATION
%
\JWltwo{Oblivious Polynomial Evaluation}
\label{sec:OPE}

This section describes the whole process of obliviously evaluating a univariate
polynomial $f(x) = \sum_{i=1}^k a_ix^i$. First of all, the first party
(\JWpOne{}) fixes the polynomial coefficients and transforms $f(x)$ to a DRAC
consisting of many DRAEs assigned to variables. The number of DRAEs will be in
$O(n)$, $n$ being the number of arithmetic operations needed by evaluate $f(x)$
as usual. To securely evaluate the DRAC, the OAFE setup is calculated by the
first party. It's important that the first party accumulates all OAFE calls
using the same variable to one OAFE call resulting in a vector. If the first
party would provide more than one OAFE that is evaluated using some variable
$v$, a corrupted party could evaluate the OAFEs with different values for $v$.

After the first party has fixed the DRAC and the OAFE configuration, it sends
them to the second party. The DRAEs inside the DRAC that get actually
transmitted to the second party resemble the pre--evaluated DRAEs from chapter
\ref{def:DRAE}. Naturally, every DRAV is replaced by a OAFE reference (and the
position in the resulting vector) that has to be used to calculate the value.

The OAFEs are sent to the second party (\JWpTwo{}) using the David \& Goliath
protocol \cite{davidgoliath}. The DRAC is transmitted using a singed and
encrypted channel.

After having received the DRAC and the OAFEs, the second party can evaluate the
DRAC. It evaluates the DRAEs one by one and assigns the resulting DRAV to the
variable as described in the DRAC. As explained in chapters
\ref{sec:drav-final-decoding} and \ref{sec:DRAC-eval} both components of the
final DRAV have then to be added and passed to the final OAFE which yields the
unencrypted evaluated value of the polynomial.

% vim: set spell spelllang=en_us fileencoding=utf8 :
