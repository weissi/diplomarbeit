\JWlone{Methods}
\label{sec:methods}

This chapter describes how arbitrary arithmetic functions can be expressed in
terms of affine expressions. This is the most important part of this thesis
because it is the key part of evaluating arbitrary arithmetic expressions
using OAFEs \cite{davidgoliath}.


%
% DEFINITIONS
%
\JWltwo{Definitions}
\label{sec:rae-definitions}

This chapter defines important entities that are used to define the more complex
entities in the following chapters.

% Field K
\JWlthree*{Field $K$}

\label{def:field} Throughout this thesis, $K$ represents an arbitrary finite
field, such as $\mathbb{F}_{2^{256}}$.


% Variables
\JWlthree*{Variables}

\label{def:variable} Variables are textual placeholders for real values.
Formally represented by

\begin{align*}
  \mathcal{V} = & \{ x \mid x~\text{a variable that can be set to an element
  $e$}, e \in K \}
\end{align*}


%
% DUAL RANDOMIZED AFFINE VALUES
%
\JWltwo{Dual Randomized Affine Values}
\label{sec:drav}

\JWdef{Dual Randomized Affine Value}{DRAV}{s} are encrypted, signed values
representing a scalar value of the field $K$. Each DRAV is encrypted by a pair
of \emph{dual keys}. The first dual key, the \emph{static key}, remains the same
in the whole DRAC (see chapter \ref{def:DRAC}) generation procedure and is
usually written as $(\alpha_l, \alpha_r)$. The second dual key, the
\emph{dynamic key} is a short--lived key, usually represented as $(\beta,
\beta')$. Two DRAVs only share the same dynamic key by hazard but always share
the same static key. Encoding a regular value $v \in K$ as a DRAV
$\widetilde{v} \in \mathcal{V}_K$ is very simple:

\begin{align*}
  \widetilde{v} = E(v) = (\widetilde{v_l}, \widetilde{v_r}) =
    (\alpha_l \cdot v + \beta, \alpha_r \cdot v + \beta')
\end{align*}

So if the keys are uniformly at random, the two components of the tuple
$\widetilde{v}$ are uniformly at random, too. Decoding is:

\begin{align*}
  v = D(\widetilde{v}) =
  \left\{
    \begin{array}{l l}
      \frac{\widetilde{v_l} - \beta}{\alpha_l} & \quad
      \text{if}~\frac{\widetilde{v_l} - \beta}{\alpha_l} =
      \frac{\widetilde{v_r} - \beta'}{\alpha_r}\\
      \bot & \quad \text{otherwise ($\widetilde{v}$ is non--well--formed)}\\
    \end{array}\right.
\end{align*}

\begin{JWtodoBox}
  \begin{itemize}
    \item Was ist well--formedness, non--well--formedness?
    \item Final Value evaluation, also Addieren der Komponenten
    \item Arithmetic auf DRAVs (kann man aus dem alten CBRAE Kapitel klauen)
  \end{itemize}
\end{JWtodoBox}


% DIRECT DRAV ARITHMETIC
\JWlthree{Direct DRAV Arithmetic}

Direct DRAV arithmetic only supports addition ($+$) of two DRAVs. Indirect DRAV
arithmetic has to be used for other operations. The advantage of direct DRAV
arithmetic is that it can be performed without the knowledge of a DRAV's
encryption keys.


\paragraph{Addition of Well--Formed DRAVs:} Two DRAVs $\widetilde{x} =
(\widetilde{x_l}, \widetilde{x_r})$ and $\widetilde{y} = (\widetilde{y_l},
\widetilde{y_r})$ can be added componentwise to $\widetilde{z} =
\left(\widetilde{x_1} + \widetilde{y_1}, \widetilde{x_2} +
\widetilde{y_2}\right)$. The encryption keys for $\widetilde{z}$ will be
$(\alpha_l, \alpha_r)$ and $(\beta_1 + \beta_3, \beta_2 + \beta4)$ assuming
$\widetilde{x}$ was encrypted with $(\alpha_l, \alpha_r)$ and $(\beta_1,
\beta_2)$ and $y$ was encrypted with $(\alpha_l, \alpha_r)$ and $(\beta_3,
\beta_4)$.

\subparagraph{Proof:} From ($\widetilde{x} = \left(\alpha_l \cdot x + \beta_1,
\alpha_r \cdot x + \beta_2\right)$, $\widetilde{y} = \left(\alpha_l \cdot x +
\beta_3, \alpha_r \cdot x + \beta_4\right)$) it's obvious that: $\widetilde{z} =
\left(\alpha_l \cdot (x+y) + (\beta_1 + \beta_3), \alpha_r \cdot (x+y) +
(\beta_2 + \beta_4)\right)$ and $\widetilde{z}$ is well--formed.

\paragraph{Addition of Non--Well--Formed DRAVs:} It's of particular interest the
following property holds: $\forall \widetilde{x}: \widetilde{x} + \bot = \bot
+ \widetilde{x} = \bot$. Let $\widetilde{\chi}$ be a non--well--formed DRAV,
so: $\widetilde{\chi} = (\alpha_l \cdot \chi + \beta_3 + \Delta_l, \alpha_r
\cdot \chi + \beta_4 + \Delta_r)$. The component--wise addition
$\widetilde{\nu}$ of $\widetilde{\chi}$ to any well--formed $\widetilde{x} =
(\alpha_l \cdot x + \beta_1, \alpha_r \cdot x + \beta_2)$ is $\widetilde{\nu} =
(\alpha_l \cdot (x+\chi) + (\beta_1+\beta_3) + \Delta_l, \alpha_r \cdot (x+\chi)
+ (\beta_2+\beta_4) + \Delta_r)$. Using the universal decoding function $D$, the
value of $\chi$ is $\chi = D(\widetilde{\chi}) = (x + \chi +
\frac{\Delta_l}{\alpha_l}, x + \chi + \frac{\Delta_r}{\alpha_r})$. So: $\forall
(\Delta_r, \Delta_l) \in K \setminus \{(0, 0)\} \wedge \frac{\Delta_l}{\alpha_l}
\neq \frac{\Delta_r}{\alpha_r}: D(\widetilde{\chi}) = \bot$. Since the
encryption keys are not known to an attacker, $\frac{\Delta_l}{\alpha_l} \neq 0
\wedge \frac{\Delta_r}{\alpha_r}$ hold except for a negligible probability if
$\Delta_r \neq 0 \vee \Delta_r \neq 0$ and that's the property for being forged
(non--well--formed) which was the assumption. Trivially $\bot + \bot = \bot$ by
a similar argument.


% INDIRECT DRAV ARITHMETIC
\JWlthree{Indirect DRAV Arithmetic}
\label{sec:drac-arithmetic}

Indirect DRAV arithmetic assumes the universal encoding and decoding functions
$E(v)$ and $D(\widetilde{v})$ and therefore the knowledge of the encryption
keys. Another possibility is to map indirect DRAV arithmetic to OAFE calls that
are set up by a party that knows the encryption keys.


% FINAL DRAV DECODING
\JWlthree{Final DRAV Decoding}
\label{sec:drav-final-decoding}

Finally decoding a DRAV can be trivially done using the universal decoding
function $D(\widetilde{v})$. But $D$ is only available to a party that is in
possession of the encryption keys.

Additionally a DRAV can also be finally decoded only one additional OAFE call.
The following procedure will decode a DRAV to a final scalar value although
$D$ is a partial function. To enable a second party---that is not in possession
of the encryption keys---to decode a DRAV $\widetilde{v} = (\widetilde{v_1},
\widetilde{v_2})$, the first party---in possession of the keys---needs to set up
a special OAFE, called the \emph{final OAFE} below.

The second party's input to the final OAFE is $\widehat{v} = \widetilde{v_1} +
\widetilde{v_2}$, the addition of both components of the DRAV to decode.  The
final OAFE was set up by the first party as follows: Assuming $\widetilde{v}$ is
encrypted by $(\alpha_l, \alpha_r)$ and $(\beta_1, \beta_2)$ the first party
knows $\widehat{v}$ has to be encrypted using $(\alpha_l + \alpha_r)$ and
$(\beta_1 + \beta_2)$.  Given this knowledge the final OAFE setup is
$\frac{1}{\alpha_l + \alpha_r} \cdot \widehat{v} - \frac{\beta_1 +
\beta_2}{\alpha_l + \alpha_r}$.

Again, it's important that an attacker is getting caught when trying to forge a
DRAV ($D(\widetilde{v}) = \bot$ if $\widetilde{v}$ has been forged, $\bot$ is
mapped to uniform randomness in this process since an OAFE has no
$\bot$--value). If the attacker cheated somewhere in the process and forged one
of the DRAV tuples $\widetilde{x} = (\widetilde{x_1}, \widetilde{x_2})$ to
$\widetilde{x'} = (\widetilde{x_1} + \Delta_1, \widetilde{x_2} + \Delta_2)$, the
DRAV $\widetilde{x'}$ becomes---except for a negligible
probability---non--well--formed (see section \ref{sec:drav}). The result is that
the decoded result will become uniform randomness (assuming $\widetilde{x}$ is
forged to $\widetilde{x'_1} = \widetilde{x_1} + \Delta_1$ and $\widetilde{x'_2}
= \widetilde{x_2} + \Delta_2$):

\begin{align*}
  \widehat{x'} = & \widetilde{x'_1} + \widetilde{x'_2} = \widetilde{x_1} +
  \Delta_1 + \widetilde{x_2} + \Delta_2 \\
  %
  \Rightarrow x' = & \frac{1}{\alpha_l + \alpha_v} \cdot \widehat{x'} -
  \frac{\beta_{x_1} +
  \beta_{x_2}}{\alpha_l + \alpha_v} \\
  %
  \Leftrightarrow x' = & \frac{\widetilde{x_1} + \Delta_1 +
  \widetilde{x_2} + \Delta_2}{\alpha_l + \alpha_v} -
  \frac{\beta_{x_1} +\beta_{x_2}}{\alpha_l + \alpha_v}\\
  %
  \Leftrightarrow x' = & \frac{(\alpha_l x + \beta_{x_1}) + \Delta_1 +
  (\alpha_v x + \beta_{x_2}) + \Delta_2}{\alpha_v + \alpha_l} -
  \frac{\beta_{x_1} +\beta_{x_2}}{\alpha_l + \alpha_v} \\
  %
  \Leftrightarrow x' = & \frac{(\alpha_l+\alpha_v)x + (\beta_{x_1}+\beta_{x_2} +
  \Delta_1+\Delta_2)}{\alpha_l+\alpha_v} -
  \frac{\beta_{x_1} +\beta_{x_2}}{\alpha_l + \alpha_v} \\
  %
  \Leftrightarrow x' = & x + \frac{\beta_{x_1}+\beta_{x_2}}{\alpha_l+\alpha_v}
  + \frac{\Delta_1 + \Delta_2}{\alpha_l + \alpha_v} -
  \frac{\beta_{x_1}+\beta_{x_2}}{\alpha_l + \alpha_v} \\
  %
  \Leftrightarrow x' = & x + \frac{\Delta_1 + \Delta_2}{\alpha_l + \alpha_v}\\
\end{align*}

Because an attacker is not in possession of the static encryption keys
$\alpha_l$ and $\alpha_r$, it cannot control the value of $\frac{\Delta_1 +
\Delta_2}{\alpha_l + \alpha_r}$. Since $\alpha_l$ and $\alpha_r$ are chosen
uniform at random, the result $x'$ becomes uniform at random, too.


%
% DUAL RANDOMIZED AFFINE ENCODING
%
\JWltwo{Dual Randomized Affine Encoding}
\label{sec:drae}

\JWdef{Dual Randomized Affine Encoding}{DRAE}{s} are affine representations of
parts of arithmetic circuits that fulfill several properties:

\begin{enumerate}

  \item \label{prop:drae-encrypted} DRAEs are encrypted: Without the encryption
    keys, they don't reveal any information.

  \item \label{prop:drae-signed} DRAEs are signed: If someone tries to forge a
    DRAE, it will become non--well--formed and operations with that DRAE result
    in non--well--formed DRAEs.

  \item \label{prop:drae-oafe} DRAEs can be securely evaluated using OAFEs.

  \item \label{prop:drae-not-enough} DRAEs can not express arbitrary arithmetic
    circuits alone.

\end{enumerate}

\noindent{}A DRAE can be eventually evaluated to a final value, that is a DRAV
(see chapter \ref{def:DRAV}).


%
% DUAL RANDOMIZED AFFINE CIRCUITS
%
\JWltwo{Dual Randomized Affine Circuits}
\label{sec:drac}

\JWdef{Dual Randomized Affine Circuit}{DRAC}{s} are representations of entire
arbitrary arithmetic circuits. DRACs are sequences of DRAEs, each assigned to a
variable.

% EVALUATION
\JWlthree{Evaluation}
\label{sec:DRAC-eval}

A DRAC can be evaluated by evaluating one DRAE after the other and assigning the
resulting DRAV to the variable the DRAE is assigned to. The DRAE sequence is
ordered, so a DRAE can be evaluated by only inputting the regular inputs
and the variables set by evaluating prior DRAEs. The last DRAV can then be
decoded as explained in chapter \ref{sec:drav-final-decoding}.


\JWltwo{DRAEs weiter...}

are very similar to AREs
(section \ref{sec:are}) but use CBRVs (section \ref{sec:cbrv}) instead of plain
values and RVs (section \ref{sec:rv}). \ref{def:LW} \ref{def:AW}

\begin{align}
  \mathcal{F}_{AR} = & \{ s \cdot x + i \mid s, i \in K, x \in \mathcal{V} \}
  \cup \{ v \mid v \in K \} \\
%
  \mathcal{B}_{AR} = & \{ (\alpha_l \cdot f + \beta, \alpha_r \cdot f + \beta' )
  \mid \alpha_l, \alpha_r \in K \setminus \{0\}; \beta, \beta' \in K; f \in
  \mathcal{F}_{AR} \} \\
%
  \label{rel:drae}
  \mathcal{E}_{AR} = & \{ (M, A) \mid
    M \subseteq \mathcal{B}_{AR} \times \mathcal{B}_{AR},
    A \subseteq, \mathcal{B}_{AR};
    A, M~\text{finite multi--sets} \}
%
\end{align}

\noindent Intuitively, $\mathcal{V}$ are ordinary inputs and CBRVs,
$\mathcal{F}_{AR}$ represent linear, encrypted particles that encode parts of
the final function. To prevent illegal information gaining by a corrupted second
party, $\mathcal{B}_{AR}$ represents checked and encoded intermediate values
(see section \ref{sec:cbrv}) that can safely be passed to untrusted parties.
$\mathcal{E}_{AR}$ is the final encoding, powerful enough to encode arbitrary
arithmetic functions. $\mathcal{E}_{AR}$s are full--blown DRAEs as presented in
this thesis. The decoding part remains as in section
\ref{sec:affinization_decoding}. The result will be a tuple that can then be
decoded in one last step as in section \ref{sec:eval-final-value}.


\JWlthree{Encoding Arithmetic Operations as DRAEs}
\label{sec:encode-drae}

\JWlfour{Addition}

Having two DRAEs, they can be added by simply concatenating the multiplicative
($M$ in relation \ref{rel:drae}) and additive ($A$) parts.


\JWlfour{Addition -- Alternative Form}

The alternative addition form is
$\widetilde{z} =
\left( E\left(D(\widetilde{x_1}) + D(\widetilde{y_1})\right),
       E\left(D(\widetilde{x_2}) + D(\widetilde{y_2})\right)
\right)$.
Since $E(x)$ and $D(x)$ are both linear functions,
$E\left(D(\ldots) +D(\ldots)\right)$
are linear expressions, too that can be evaluated using two OAFE calls.


\JWlfour{Multiplication}

As for ordinary AREs, the multiplication is not as powerful as the addition,
direct multiplication of two DRAEs is not possible. DRAE multiplication is
done using CBRVs sent to the second party. Then, these CBRVs get multiplied as
described here:

\begin{align*}
  e & \in \mathcal{E}_{AR}; \widetilde{x}, \widetilde{y} \in \mathcal{B}_{RV};
  r_1, r_2, r_3, r_4, r_5, r_6, r_7, r_8 \in K;
  \alpha_l, \alpha_r \in K \setminus \{0\} \\
  %
  e & = \widetilde{x} \otimes \widetilde{y} \\
  %
  e & = \Bigg(\Big\{\big( \alpha_l \cdot D(\widetilde{x_1}) - r_1,
                          \alpha_r \cdot D(\widetilde{x_2}) -r_5 \big) \\
    &\qquad ,     \big(   1        \cdot D(\widetilde{y_1}) - r_2,
                          1        \cdot D(\widetilde{y_2}) - r_6 \big) \Big\}\\
    &\qquad   \Big\{\big( \alpha_lr_2 \cdot D(\widetilde{x_2}) + r_3,
                          \alpha_rr_2 \cdot D(\widetilde{x_1}) + r_7 \big) \\
    &\qquad ,       \big ( r_1        \cdot D(\widetilde{y_2}) + r_4,
                           r_5        \cdot D(\widetilde{y_1}) + r_8 \big)
              \Big\}\Bigg) \\
\end{align*}

The decryption keys of $e$ are $\alpha_l$, $\alpha_r$ (static keys) and
$\beta = r_1r_2 + r_3 + r_4$, $\beta' = r_5r_6 + r_7 + r_8$ (dynamic keys).

\JWltwo{Checked Bi--Randomized Variables}
\label{sec:cbrv}

The RV technique (see section \ref{sec:rv}) prevents the
second party from directly gaining intermediate information. But, for a
corrupted second party, there is still the possibility of gaining supplemental
information: The second party could forge an RV value before applying it to one
of the following AREs. This will not directly reveal additional information
because the second party does not know the encryption keys used for the RV. So,
the second party is unaware of the decoded value of the RV. But except for a
negligible probability $\left(\frac{1}{Char(K)}\right)$, the decoded value is
non--zero.  The knowledge of a random but non--zero value can then be used to
test a secret input of the first party against zero. \JWtodo{Beispiel hierfür,
siehe z.B. Google Doc.}

To address this issue, a similar but secure technique is proposed in here: The
\emph{Checked Bi--Randomized Variables} (CBRVs). Every input made to an OAFE by
the second party is encoded as a CBRV. The CBRVs $\hat{v}$ corresponding to a
value $v$ are: ($\alpha_l, \alpha_r \in K \setminus \{0\}; \beta, \beta' \in K$)

\begin{align*}
  \widetilde{v} = (\widetilde{v_1}, \widetilde{v_2}) =
  (\alpha_l \cdot v + \beta, \alpha_r \cdot v + \beta')
\end{align*}

\noindent{} $\alpha_l$ and $\alpha_r$ are the \emph{static keys}, $\beta$ and
$\beta'$ the \emph{dynamic keys} of the CBRV. The static keys are (non--zero)
numbers uniformly at random but constant for the entire procedure. $\beta$ and
$\beta'$ are fresh, independent and uniformly distributed random numbers for
every CBRV component generated while processing a circuit. Only the first party
knows these secret keys. The initial CBRVs used to feed the second party's
regular inputs party are generated using an OAFE that evaluates for every input
$x$:

\begin{align*}
  \widetilde{x} = (\alpha_l \cdot x + \beta_1, \alpha_r \cdot x + \beta_2)
\end{align*}

The first party is---because it generates and knows all the keys---in possession
of the encoding and decoding functions

\begin{align*}
  E(x) &= \left(\alpha_l \cdot x + \beta_1, \alpha_r \cdot x + \beta_2\right) \\
  D(\widetilde{x}) &= \left(\frac{\widetilde{x_1} - \beta_1}{\alpha_l},
                       \frac{\widetilde{x_2} - \beta_2}{\alpha_r}\right)
\end{align*}

A CBRF $\widetilde{x}$ is well--formed iff the tuple $D(\widetilde{x})$ consists
of two equal values.




%
% PREPARING DRAE EVALUATION USING OAFEs
%
\JWltwo{Preparing DRAE Evaluation Using OAFEs}
\label{sec:prep-eval}

After transforming an arithmetic expressing to DRAEs (section \ref{sec:drae})
assigned to CBRVs (section \ref{sec:cbrv}) the OAFEs (\cite{davidgoliath}) need
to be set up. First of all, two separate OAFEs have to be set up for each CBRV
that can be evaluated later on as soon the value is known. The OAFEs are
configured with the linear expressions inside the DRAEs. Each DRAE is then
transformed to two \emph{Encoding Descriptors} (EDs) that have the same
structure as the DRAEs but contain OAFE references instead of linear
expressions. Therefore, each DRAE assigned to a CBRV gets transformed to two
EDs, because of the tuple form of the CBRVs and DRAEs.


%
% OBLIVIOUS POLYNOMIAL EVALUATION
%
\JWltwo{Oblivious Polynomial Evaluation}
\label{sec:ope}

This section describes the whole process of obliviously evaluating a univariate
polynomial $f(x) = \sum_{i=1}^k a_ix^i$. The first party (\JWpOne{}) fixes the
polynomial and configures the OAFEs, the second party (\JWpTwo{}) chooses input
$x$. Eventually, \JWpTwo{} will learn $f(x)$ but not the polynomial's
coefficients $a_i$. \JWpOne{} will not learn anything at all.

The first step is to transform $f$ to OAFEs and EDs (section
\ref{sec:prep-eval}). The OAFEs are then sent to the second party (\JWpTwo{})
using the David \& Goliath protocol \cite{davidgoliath}, the EDs are sent to the
second party using an encrypted channel aswell.

After having received the OAFEs and EDs, the first party (\JWpOne{}) is not
needed anymore and the second party (\JWpTwo{}) can evaluate the polynomial by
itself. To run the evaluation, the second party just evaluated the EDs one by
one. After each evaluation, it queries the respective OAFE (should be the next)
with the value if did just calculate. After having calculated the last to ED
values, it queries a special OAFE (see section \ref{sec:eval-final-value}) using
the addition of the values of the last two EDs. The evaluation of the special
OAFE is the result of the whole computation.

% vim: set spell spelllang=en_us fileencoding=utf8 :
