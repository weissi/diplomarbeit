\JWlone{Implementation}
\label{sec:implementation}

In addition to the mathematical methods (chapter \ref{sec:methods}), the
protocol description (chapter \ref{sec:protocol}) and the security proof of the
protocol in the UC framework (chapter \ref{sec:security}), this thesis contains
an implementation of the protocol. The implementation is written in the lazy,
functional programming language \JWTLhaskell{}. More specifically \JWThaskell{}
as implemented by the major \JWThaskell{} compiler the \JWTXLghc{} (\JWTghc{})
version \JWTVghc{}.

The implementation was designed to match the descriptions in the above chapters
as closely as possible. The implementation implements Oblivious Polynomial
Evaluation as explained in chapter \ref{def:OPE}.

Even the Haskell data--types such as \JWcode{DRAC}, \JWcode{DRAE}, \JWcode{RAE},
\JWcode{LinearExpr} match the names of the constructs described in chapter
\ref{sec:methods}: DRACs (chapter \ref{def:DRAC}), DRAEs (chapter
\ref{def:DRAE}) and linear expressions (named $\mathcal{C}$ in chapter
\ref{def:DRAE}). For practical reasons the program also features \JWcode{RAC}
(Randomized Affine Circuits) and \JWcode{RAE} (Randomized Affine Encodings)
which are the same as their \emph{dual} counterparts but split into the
components. So while running the program two \JWcode{RAE}s are derived from one
\JWcode{DRAE}.

As in chapter \ref{def:OPE}, the oblivious polynomial evaluation consists of
three parties: The tamper--proof hardware issuing party \JWpOne{} (executable
program called \JWBpOne{}), the receiving party \JWpTwo{} (\JWBpTwo{}) and the
tamper--proof hardware \JWtoken{} (\JWBtoken{}). The individual programs talk to
each other using TCP/IP networking. The \JWtoken{} implements the OAFE
functionality \JWfuncSym{seq-ot}{OAFE} as provided by the David \& Goliath
protocol \cite{davidgoliath}. The \JWtoken{} does not actually implement the
David \& Goliath protocol but only it's interface. A real implementation using a
tamper--proof hardware token is left open to potential future works.


%
% COMMUNICATION CHANNELS
%
\JWltwo{Communication Channels and Their TCP Ports}
\label{sec:communication-channels}


% GOLIATH TO TOKEN
\JWlthree{\JWpOne{} To \JWtoken{}}
\label{sec:comm:goliath2Token}

On TCP port \JWport{23120} \JWpOne{} initiates a connection to the \JWtoken{}.
This connection is used to transfer the OAFE configuration to the tamper--proof
hardware token.


% DAVID TO TOKEN
\JWlthree{\JWpTwo{} To \JWtoken{}}
\label{sec:comm:david2token}

On TCP port \JWport{23021} \JWpTwo{} initiates a connection to the \JWtoken{}.
This connection is used to evaluate the OAFEs. \JWpTwo{} sends a tells which
OAFE to evaluate and its value, the \JWtoken{} then replies with a vector
consisting of the evaluated linear expressions.


% GOLIATH TO DAVID
\JWlthree{\JWpOne{} To \JWpTwo{}}
\label{sec:comm:goliath2david}

On TCP port \JWport{23102} \JWpOne{} initiates a connection to \JWpTwo{}. This
connection streams the DRAC that \JWpTwo{} will evaluate.


% DAVID TO GOLIATH
\JWlthree{\JWpTwo{} To \JWpOne{}}
\label{sec:comm:david2goliath}

On TCP port \JWport{23201} \JWpTwo{} initiates a connection to \JWpOne{}. This
connection is not necessary for the protocol itself but is used to exchange
settings between \JWpOne{} and \JWpTwo{}. \JWpOne{} tells \JWpTwo{} the host
name and the TCP port of the \JWtoken{} and \JWpTwo{} tells \JWpOne{} the port
on which \JWpTwo{} accepts the DRAE stream.


%
% DIFFERENCES BETWEEN IMPLEMENTATION AND WRITING
%
\JWltwo{Differences Between the Implementation and this Writing}
\label{sec:implementation-differences}

\begin{JWtodoBox}

\begin{itemize}

\item Communication Channel from \JWpTwo{} to \JWpOne{}
(\ref{sec:comm:david2goliath})

\item THERE IS NOT TAMPER-PROOF HARWARE TOKEN

\end{itemize}

\end{JWtodoBox}


%
% IMPLEMENTATION DETAILS
%
\JWltwo{Implementation Details}
\label{sec:implementation-details}

% Calculations in Finite Fields
\JWlthree{Calculations in Finite Fields}
\label{sec:finite-field-calcs}

For the calculation in the finite fields (chapter \ref{sec:field}) the
\JWTcpp{} library \JWTLntl{} (\emph{Number Theory Library}) has been interfaced
to \JWThaskell{} for the purpose of developing the implementation of this
thesis. The interface has been developed using \JWThaskell{}'s \JWdef{Foreign
Function Interface}{FFI} \cite{haskell2010} and \JWdef{C $\longrightarrow$
Haskell}{C2Hs} \cite{c2hs}. Prior to interfacing the library to Haskell a very
lightweight \JWTc{} wrapper has been developed because the library is written in
\JWTcpp{} which cannot directly be interfaced using the FFI.

\begin{JWtodoBox}

  IST WICHTIG, DARAUF REFERNZIERE ICH IN EVALUATION

  \begin{itemize}

    \item Garbage--Collector bekommt Probleme weil \texttt{delete} lange braucht

    \item Viel Indirektion

    \item Viel Speicher (32 bytes + 3 Pointer oder so)

  \end{itemize}

\end{JWtodoBox}


% Thread Safety
\JWlthree{Thread Safety}

The implementation is fully threadsafe, all communication is done using
\JWTghc{}'s implementation of \emph{Software Transactional Memory} (STM)
\cite{stm05} for Haskell.


% Testing Correctness
\JWlthree{Testing the Correctness of the Implementation}

The correctness of the implementation has not been proofed since that is not
feasible for complex programs. Instead of a real proof, the implementation
has been tested using the specification--driven automatic \JWThaskell{} testing
tool \JWTquickcheck{} \cite{quickcheck} and the classic unit test approach of
\JWTLhunit{}.


% Randomness
\JWlthree{Cryptographic Randomness}

The random numbers needed for the implementation of this thesis are generated
using \JWTLmonadcryptorandom{}.


% Communication Layer
\JWlthree{Communication Layer}

The communication layer between the different binaries is driven by the
schrieblesque \JWTXLprotobuf{}.


% Other Libraries
\JWlthree{Other Libraries}

This thesis uses a lot of other libraries mainly from \JWTLhackage{}. The
complete list of packages can be extracted from the file
\JWpath{diplomarbeit.cabal} that comes with the source code of this thesis.


% Source Tree Organization
\JWlthree{Source Tree Organization}
\label{sec:src-org}

\JWtodo{WICHTIG: Ist referenziert im LBS chapter}


% Build System
\JWlthree{Build System and Building}

The implementation can be easily built using \JWTLcabal{} by typing:

\begin{lstlisting}

cd diplomarbeit/
cabal install --only-dependencies
cabal configure
cabal build

\end{lstlisting}


%
% USER INPUT/OUTPUT
%
\JWltwo{User Input/Output}
\label{sec:user-io}

Whenever field elements in large fields that are no prime fields (e.g.\ %
$\mathbb{F}_{2^{256}}$) are read from user input or are outputted to the user,
the following format (given as a regular expression) is used:

\JWcode{\textbackslash[([01]( [01])\{0,255\})?\textbackslash]}

Intuitively that is between $0$ and $256$ digits (each \JWcode{0} or \JWcode{1})
separated by spaces and surrounded by square brackets. The meaning of such a
string is $\sum_{i=1}^P d \cdot x^p$ where $p$ is the position of the digit in
the string and $P$ is the maximal position (counted from $0$). And exception is
the string \JWcode{[]} which represents the polynomial \JWcode{0}. Examples:

\begin{itemize}

  \item \JWcode{[]} and \JWcode{[0]} represent $0$

  \item \JWcode{[1]} represents $1 \cdot x^0 = 1 \cdot 1 = 1$

  \item \JWcode{[0 1]} represents $0 + 1 \cdot x^1 = x$

  \item \JWcode{[1 0]} represents $1 + 0 \cdot x^1 = 1$

  \item \JWcode{[1 1]} represents $1 + 1 \cdot x^1 = 1 + x$

  \item \JWcode{[1 0 1 0 1 0]} represents $1 + x^2 + x^4$

\end{itemize}

The default implementation uses $\mathbb{F}_{2^{256}}$ specified by the
irreducible polynomial $1 + x^2 + x^5 + x^{10} + x^{256}$. The $\mathbb{F}_{97}$
implementation uses regular digits to read and write the field elements because
it is a prime field. Examples: $1 \hat{=} 1 (mod 97) = 1_{\mathbb{F}_{97}}$, $98
\hat{=} 98 (mod 97) = 1_{\mathbb{F}_{97}}$.


%
% USAGE OF THE PROGRAMS
%
\JWltwo{Usage of the Programs}
\label{sec:usage}

The three main programs are \JWBpOne{}, \JWBpTwo{} and \JWBtoken{}. \JWBtoken{}
does not accept any command line parameters. \JWpOne{} expects exactly one
command line parameter: The file for the polynomial to evaluate, one coefficient
per line. \JWpTwo{} expects exactly one parameter, too: The field element to
evaluate the polynomial. Example:

\JWcmd{Goliath /tmp/my-polynomial.txt}

\JWcmd{Token}

\JWcmd{David '[1 0 1 1 1 0 1]'}


%
% DOCUMENTATION
%
\JWltwo{Documentation}
\label{sec:implementation-doc}

The implementation is documented using \JWTLhaddock{}.

\JWtodo{Add link to Haddock doc}


%
% CODE AVAILABILITY
%
\JWltwo{Code Availability}
\label{sec:code-availability}

All of the code is open--sourced and available at...
\JWtodo{Add link to GitHub repo}


% vim: set spell spelllang=en_us fileencoding=utf8 :
